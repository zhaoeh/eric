<!doctype html>
<html>
<head>
    <meta charset='UTF-8'>
    <meta name='viewport' content='width=device-width initial-scale=1'>
    <title>对象循环依赖.md</title>
    <link href='http://fonts.googleapis.com/css?family=Open+Sans:400italic,700italic,700,400&subset=latin,latin-ext'
          rel='stylesheet' type='text/css'/>
    <style type='text/css'>html {
        overflow-x: initial !important;
    }

    .CodeMirror {
        height: auto;
    }

    .CodeMirror-scroll {
        overflow-y: hidden;
        overflow-x: auto;
    }

    .CodeMirror-lines {
        padding: 4px 0px;
    }

    .CodeMirror pre {
    }

    .CodeMirror-scrollbar-filler, .CodeMirror-gutter-filler {
        background-color: white;
    }

    .CodeMirror-gutters {
        border-right: 1px solid rgb(221, 221, 221);
        background-color: rgb(247, 247, 247);
        white-space: nowrap;
    }

    .CodeMirror-linenumbers {
    }

    .CodeMirror-linenumber {
        padding: 0px 3px 0px 5px;
        text-align: right;
        color: rgb(153, 153, 153);
    }

    .CodeMirror div.CodeMirror-cursor {
        border-left: 1px solid black;
        z-index: 3;
    }

    .CodeMirror div.CodeMirror-secondarycursor {
        border-left: 1px solid silver;
    }

    .CodeMirror.cm-keymap-fat-cursor div.CodeMirror-cursor {
        width: auto;
        border: 0px;
        background: rgb(119, 238, 119);
        z-index: 1;
    }

    .CodeMirror div.CodeMirror-cursor.CodeMirror-overwrite {
    }

    .cm-tab {
        display: inline-block;
    }

    .cm-s-typora-default .cm-header, .cm-s-typora-default .cm-property {
        color: rgb(217, 79, 138);
    }

    .cm-s-typora-default pre.cm-header1:not(.cm-atom) :not(.cm-overlay) {
        font-size: 2rem;
        line-height: 2rem;
    }

    .cm-s-typora-default pre.cm-header2:not(.cm-atom) :not(.cm-overlay) {
        font-size: 1.4rem;
        line-height: 1.4rem;
    }

    .cm-s-typora-default .cm-atom, .cm-s-typora-default .cm-number {
        color: rgb(149, 132, 134);
    }

    .cm-s-typora-default .cm-table-row, .cm-s-typora-default .cm-block-start {
        font-family: monospace;
    }

    .cm-s-typora-default .cm-comment, .cm-s-typora-default .cm-code {
        color: rgb(74, 90, 159);
        font-family: monospace;
    }

    .cm-s-typora-default .cm-tag {
        color: rgb(169, 68, 66);
    }

    .cm-s-typora-default .cm-string {
        color: rgb(126, 134, 169);
    }

    .cm-s-typora-default .cm-link {
        color: rgb(196, 122, 15);
        text-decoration: underline;
    }

    .cm-s-typora-default .cm-variable-2, .cm-s-typora-default .cm-variable-1 {
        color: inherit;
    }

    .cm-s-typora-default .cm-overlay {
        font-family: monospace;
    }

    .CodeMirror.cm-s-typora-default div.CodeMirror-cursor {
        border-left: 3px solid rgb(228, 98, 154);
    }

    .cm-s-typora-default .CodeMirror-activeline-background {
        left: -60px;
        right: -30px;
        background: rgba(204, 204, 204, 0.2);
    }

    .cm-s-typora-default .CodeMirror-gutters {
        border-right: none;
        background-color: inherit;
    }

    .cm-s-typora-default .cm-trailing-space-new-line::after, .cm-startspace::after, .cm-starttab .cm-tab::after {
        content: "•";
        position: absolute;
        left: 0px;
        opacity: 0;
        font-family: LetterGothicStd, monospace;
    }

    .os-windows .cm-startspace::after, .os-windows .cm-starttab .cm-tab::after {
        left: -0.1em;
    }

    .cm-starttab .cm-tab::after {
        content: " ";
    }

    .cm-startspace, .cm-tab, .cm-starttab, .cm-trailing-space-a, .cm-trailing-space-b, .cm-trailing-space-new-line {
        font-family: monospace;
        position: relative;
    }

    .cm-s-typora-default .cm-trailing-space-new-line::after {
        content: "↓";
        opacity: 0.3;
    }

    .cm-s-inner .cm-keyword {
        color: rgb(119, 0, 136);
    }

    .cm-s-inner .cm-atom, .cm-s-inner.cm-atom {
        color: rgb(34, 17, 153);
    }

    .cm-s-inner .cm-number {
        color: rgb(17, 102, 68);
    }

    .cm-s-inner .cm-def {
        color: rgb(0, 0, 255);
    }

    .cm-s-inner .cm-variable {
        color: black;
    }

    .cm-s-inner .cm-variable-2 {
        color: rgb(0, 85, 170);
    }

    .cm-s-inner .cm-variable-3 {
        color: rgb(0, 136, 85);
    }

    .cm-s-inner .cm-property {
        color: black;
    }

    .cm-s-inner .cm-operator {
        color: rgb(152, 26, 26);
    }

    .cm-s-inner .cm-comment, .cm-s-inner.cm-comment {
        color: rgb(170, 85, 0);
    }

    .cm-s-inner .cm-string {
        color: rgb(170, 17, 17);
    }

    .cm-s-inner .cm-string-2 {
        color: rgb(255, 85, 0);
    }

    .cm-s-inner .cm-meta {
        color: rgb(85, 85, 85);
    }

    .cm-s-inner .cm-qualifier {
        color: rgb(85, 85, 85);
    }

    .cm-s-inner .cm-builtin {
        color: rgb(51, 0, 170);
    }

    .cm-s-inner .cm-bracket {
        color: rgb(153, 153, 119);
    }

    .cm-s-inner .cm-tag {
        color: rgb(17, 119, 0);
    }

    .cm-s-inner .cm-attribute {
        color: rgb(0, 0, 204);
    }

    .cm-s-inner .cm-header, .cm-s-inner.cm-header {
        color: blue;
    }

    .cm-s-inner .cm-quote, .cm-s-inner.cm-quote {
        color: rgb(0, 153, 0);
    }

    .cm-s-inner .cm-hr, .cm-s-inner.cm-hr {
        color: rgb(153, 153, 153);
    }

    .cm-s-inner .cm-link, .cm-s-inner.cm-link {
        color: rgb(0, 0, 204);
    }

    .cm-negative {
        color: rgb(221, 68, 68);
    }

    .cm-positive {
        color: rgb(34, 153, 34);
    }

    .cm-header, .cm-strong {
        font-weight: bold;
    }

    .cm-del {
        text-decoration: line-through;
    }

    .cm-em {
        font-style: italic;
    }

    .cm-link {
        text-decoration: underline;
    }

    .cm-error {
        color: rgb(255, 0, 0);
    }

    .cm-invalidchar {
        color: rgb(255, 0, 0);
    }

    .cm-constant {
        color: rgb(38, 139, 210);
    }

    .cm-defined {
        color: rgb(181, 137, 0);
    }

    div.CodeMirror span.CodeMirror-matchingbracket {
        color: rgb(0, 255, 0);
    }

    div.CodeMirror span.CodeMirror-nonmatchingbracket {
        color: rgb(255, 34, 34);
    }

    .cm-s-inner .CodeMirror-activeline-background {
        background: inherit;
    }

    .CodeMirror {
        position: relative;
        overflow: hidden;
    }

    .CodeMirror-scroll {
        margin-bottom: -30px;
        margin-right: -30px;
        padding-bottom: 30px;
        padding-right: 30px;
        height: 100%;
        outline: none;
        position: relative;
        box-sizing: content-box;
    }

    .CodeMirror-sizer {
        position: relative;
    }

    .CodeMirror-vscrollbar, .CodeMirror-hscrollbar, .CodeMirror-scrollbar-filler, .CodeMirror-gutter-filler {
        position: absolute;
        z-index: 6;
        display: none;
    }

    .CodeMirror-vscrollbar {
        right: 0px;
        top: 0px;
        overflow-x: hidden;
        overflow-y: scroll;
    }

    .CodeMirror-hscrollbar {
        bottom: 0px;
        left: 0px;
        overflow-y: hidden;
        overflow-x: scroll;
    }

    .CodeMirror-scrollbar-filler {
        right: 0px;
        bottom: 0px;
    }

    .CodeMirror-gutter-filler {
        left: 0px;
        bottom: 0px;
    }

    .CodeMirror-gutters {
        position: absolute;
        left: 0px;
        top: 0px;
        padding-bottom: 30px;
        z-index: 3;
    }

    .CodeMirror-gutter {
        white-space: normal;
        height: 100%;
        box-sizing: content-box;
        padding-bottom: 30px;
        margin-bottom: -32px;
        display: inline-block;
    }

    .CodeMirror-gutter-wrapper {
        position: absolute;
        z-index: 4;
        background: none !important;
        border: none !important;
    }

    .CodeMirror-gutter-background {
        position: absolute;
        top: 0px;
        bottom: 0px;
        z-index: 4;
    }

    .CodeMirror-gutter-elt {
        position: absolute;
        cursor: default;
        z-index: 4;
    }

    .CodeMirror-lines {
        cursor: text;
    }

    .CodeMirror pre {
        border-radius: 0px;
        border-width: 0px;
        background: transparent;
        font-family: inherit;
        font-size: inherit;
        margin: 0px;
        white-space: pre;
        word-wrap: normal;
        color: inherit;
        z-index: 2;
        position: relative;
        overflow: visible;
    }

    .CodeMirror-wrap pre {
        word-wrap: break-word;
        white-space: pre-wrap;
        word-break: normal;
    }

    .CodeMirror-code pre {
        border-right: 30px solid transparent;
        width: fit-content;
    }

    .CodeMirror-wrap .CodeMirror-code pre {
        border-right: none;
        width: auto;
    }

    .CodeMirror-linebackground {
        position: absolute;
        left: 0px;
        right: 0px;
        top: 0px;
        bottom: 0px;
        z-index: 0;
    }

    .CodeMirror-linewidget {
        position: relative;
        z-index: 2;
        overflow: auto;
    }

    .CodeMirror-widget {
    }

    .CodeMirror-wrap .CodeMirror-scroll {
        overflow-x: hidden;
    }

    .CodeMirror-measure {
        position: absolute;
        width: 100%;
        height: 0px;
        overflow: hidden;
        visibility: hidden;
    }

    .CodeMirror-measure pre {
        position: static;
    }

    .CodeMirror div.CodeMirror-cursor {
        position: absolute;
        visibility: hidden;
        border-right: none;
        width: 0px;
    }

    .CodeMirror div.CodeMirror-cursor {
        visibility: hidden;
    }

    .CodeMirror-focused div.CodeMirror-cursor {
        visibility: inherit;
    }

    .CodeMirror-selected {
        background: rgb(217, 217, 217);
    }

    .CodeMirror-focused .CodeMirror-selected {
        background: rgb(215, 212, 240);
    }

    .cm-searching {
        background: rgba(255, 255, 0, 0.4);
    }

    .CodeMirror span {
    }

    @media print {
        .CodeMirror div.CodeMirror-cursor {
            visibility: hidden;
        }
    }

    .CodeMirror-lint-markers {
        width: 16px;
    }

    .CodeMirror-lint-tooltip {
        background-color: infobackground;
        border: 1px solid black;
        border-radius: 4px;
        color: infotext;
        font-family: monospace;
        overflow: hidden;
        padding: 2px 5px;
        position: fixed;
        white-space: pre-wrap;
        z-index: 10000;
        max-width: 600px;
        opacity: 0;
        transition: opacity 0.4s;
        font-size: 0.8em;
    }

    .CodeMirror-lint-mark-error, .CodeMirror-lint-mark-warning {
        background-position: left bottom;
        background-repeat: repeat-x;
    }

    .CodeMirror-lint-mark-error {
        background-image: url("data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAQAAAADCAYAAAC09K7GAAAAAXNSR0IArs4c6QAAAAZiS0dEAP8A/wD/oL2nkwAAAAlwSFlzAAALEwAACxMBAJqcGAAAAAd0SU1FB9sJDw4cOCW1/KIAAAAZdEVYdENvbW1lbnQAQ3JlYXRlZCB3aXRoIEdJTVBXgQ4XAAAAHElEQVQI12NggIL/DAz/GdA5/xkY/qPKMDAwAADLZwf5rvm+LQAAAABJRU5ErkJggg==");
    }

    .CodeMirror-lint-marker-error, .CodeMirror-lint-marker-warning {
        background-position: center center;
        background-repeat: no-repeat;
        cursor: pointer;
        display: inline-block;
        height: 16px;
        width: 16px;
        vertical-align: middle;
        position: relative;
    }

    .CodeMirror-lint-message-error, .CodeMirror-lint-message-warning {
        padding-left: 18px;
        background-position: left top;
        background-repeat: no-repeat;
    }

    .CodeMirror-lint-marker-error, .CodeMirror-lint-message-error {
        background-image: url("data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAABAAAAAQCAMAAAAoLQ9TAAAAHlBMVEW7AAC7AACxAAC7AAC7AAAAAAC4AAC5AAD///+7AAAUdclpAAAABnRSTlMXnORSiwCK0ZKSAAAATUlEQVR42mWPOQ7AQAgDuQLx/z8csYRmPRIFIwRGnosRrpamvkKi0FTIiMASR3hhKW+hAN6/tIWhu9PDWiTGNEkTtIOucA5Oyr9ckPgAWm0GPBog6v4AAAAASUVORK5CYII=");
    }

    .CodeMirror-lint-marker-warning, .CodeMirror-lint-message-warning {
        background-image: url("data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAABAAAAAQCAMAAAAoLQ9TAAAANlBMVEX/uwDvrwD/uwD/uwD/uwD/uwD/uwD/uwD/uwD6twD/uwAAAADurwD2tQD7uAD+ugAAAAD/uwDhmeTRAAAADHRSTlMJ8mN1EYcbmiixgACm7WbuAAAAVklEQVR42n3PUQqAIBBFUU1LLc3u/jdbOJoW1P08DA9Gba8+YWJ6gNJoNYIBzAA2chBth5kLmG9YUoG0NHAUwFXwO9LuBQL1giCQb8gC9Oro2vp5rncCIY8L8uEx5ZkAAAAASUVORK5CYII=");
    }

    .CodeMirror-lint-marker-multiple {
        background-image: url("data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAcAAAAHCAMAAADzjKfhAAAACVBMVEUAAAAAAAC/v7914kyHAAAAAXRSTlMAQObYZgAAACNJREFUeNo1ioEJAAAIwmz/H90iFFSGJgFMe3gaLZ0od+9/AQZ0ADosbYraAAAAAElFTkSuQmCC");
        background-repeat: no-repeat;
        background-position: right bottom;
        width: 100%;
        height: 100%;
    }


    :root {
        --bg-color: #ffffff;
        --text-color: #333333;
        --code-block-bg-color: inherit;
    }

    html {
        font-size: 14px;
        background-color: var(--bg-color);
        color: var(--text-color);
        font-family: "Helvetica Neue", Helvetica, Arial, sans-serif;
        -webkit-font-smoothing: antialiased;
    }

    body {
        margin: 0px;
        padding: 0px;
        height: auto;
        bottom: 0px;
        top: 0px;
        left: 0px;
        right: 0px;
        font-size: 1rem;
        line-height: 1.42857;
        overflow-x: hidden;
        background: inherit;
    }

    a:active, a:hover {
        outline: 0px;
    }

    .in-text-selection, ::selection {
        background: rgb(181, 214, 252);
        text-shadow: none;
    }

    #write {
        margin: 0px auto;
        height: auto;
        width: inherit;
        word-break: normal;
        word-wrap: break-word;
        position: relative;
        padding-bottom: 70px;
        white-space: pre-wrap;
        overflow-x: visible;
    }

    .for-image #write {
        padding-left: 8px;
        padding-right: 8px;
    }

    body.typora-export {
        padding-left: 30px;
        padding-right: 30px;
    }

    @media screen and (max-width: 500px) {
        body.typora-export {
            padding-left: 0px;
            padding-right: 0px;
        }

        .CodeMirror-sizer {
            margin-left: 0px !important;
        }

        .CodeMirror-gutters {
            display: none !important;
        }
    }

    .typora-export #write {
        margin: 0px auto;
    }

    #write > p:first-child, #write > ul:first-child, #write > ol:first-child, #write > pre:first-child, #write > blockquote:first-child, #write > div:first-child, #write > table:first-child {
        margin-top: 30px;
    }

    #write li > table:first-child {
        margin-top: -20px;
    }

    img {
        max-width: 100%;
        vertical-align: middle;
    }

    input, button, select, textarea {
        color: inherit;
        font-style: inherit;
        font-variant: inherit;
        font-weight: inherit;
        font-stretch: inherit;
        font-size: inherit;
        line-height: inherit;
        font-family: inherit;
    }

    input[type="checkbox"], input[type="radio"] {
        line-height: normal;
        padding: 0px;
    }

    ::before, ::after, * {
        box-sizing: border-box;
    }

    #write p, #write h1, #write h2, #write h3, #write h4, #write h5, #write h6, #write div, #write pre {
        width: inherit;
    }

    #write p, #write h1, #write h2, #write h3, #write h4, #write h5, #write h6 {
        position: relative;
    }

    h1 {
        font-size: 2rem;
    }

    h2 {
        font-size: 1.8rem;
    }

    h3 {
        font-size: 1.6rem;
    }

    h4 {
        font-size: 1.4rem;
    }

    h5 {
        font-size: 1.2rem;
    }

    h6 {
        font-size: 1rem;
    }

    p {
        -webkit-margin-before: 1rem;
        -webkit-margin-after: 1rem;
        -webkit-margin-start: 0px;
        -webkit-margin-end: 0px;
    }

    .typora-export p {
        white-space: normal;
    }

    .mathjax-block {
        margin-top: 0px;
        margin-bottom: 0px;
        -webkit-margin-before: 0rem;
        -webkit-margin-after: 0rem;
    }

    .hidden {
        display: none;
    }

    .md-blockmeta {
        color: rgb(204, 204, 204);
        font-weight: bold;
        font-style: italic;
    }

    a {
        cursor: pointer;
    }

    sup.md-footnote {
        padding: 2px 4px;
        background-color: rgba(238, 238, 238, 0.7);
        color: rgb(85, 85, 85);
        border-radius: 4px;
    }

    #write input[type="checkbox"] {
        cursor: pointer;
        width: inherit;
        height: inherit;
        margin: 4px 0px 0px;
    }

    tr {
        break-inside: avoid;
        break-after: auto;
    }

    thead {
        display: table-header-group;
    }

    table {
        border-collapse: collapse;
        border-spacing: 0px;
        width: 100%;
        overflow: auto;
        break-inside: auto;
        text-align: left;
    }

    table.md-table td {
        min-width: 80px;
    }

    .CodeMirror-gutters {
        border-right: 0px;
        background-color: inherit;
    }

    .CodeMirror {
        text-align: left;
    }

    .CodeMirror-placeholder {
        opacity: 0.3;
    }

    .CodeMirror pre {
        padding: 0px 4px;
    }

    .CodeMirror-lines {
        padding: 0px;
    }

    div.hr:focus {
        cursor: none;
    }

    pre {
        white-space: pre-wrap;
    }

    .CodeMirror-gutters {
        margin-right: 4px;
    }

    .md-fences {
        font-size: 0.9rem;
        display: block;
        break-inside: avoid;
        text-align: left;
        overflow: visible;
        white-space: pre;
        background: var(--code-block-bg-color);
        position: relative !important;
    }

    .md-diagram-panel {
        width: 100%;
        margin-top: 10px;
        text-align: center;
        padding-top: 0px;
        padding-bottom: 8px;
        overflow-x: auto;
    }

    .md-fences .CodeMirror.CodeMirror-wrap {
        top: -1.6em;
        margin-bottom: -1.6em;
    }

    .md-fences.mock-cm {
        white-space: pre-wrap;
    }

    .show-fences-line-number .md-fences {
        padding-left: 0px;
    }

    .show-fences-line-number .md-fences.mock-cm {
        padding-left: 40px;
    }

    .footnotes {
        opacity: 0.8;
        font-size: 0.9rem;
        padding-top: 1em;
        padding-bottom: 1em;
    }

    .footnotes + .footnotes {
        margin-top: -1em;
    }

    .md-reset {
        margin: 0px;
        padding: 0px;
        border: 0px;
        outline: 0px;
        vertical-align: top;
        background: transparent;
        text-decoration: none;
        text-shadow: none;
        float: none;
        position: static;
        width: auto;
        height: auto;
        white-space: nowrap;
        cursor: inherit;
        -webkit-tap-highlight-color: transparent;
        line-height: normal;
        font-weight: normal;
        text-align: left;
        box-sizing: content-box;
        direction: ltr;
    }

    li div {
        padding-top: 0px;
    }

    blockquote {
        margin: 1rem 0px;
    }

    li p, li .mathjax-block {
        margin: 0.5rem 0px;
    }

    li {
        margin: 0px;
        position: relative;
    }

    blockquote > :last-child {
        margin-bottom: 0px;
    }

    blockquote > :first-child {
        margin-top: 0px;
    }

    .footnotes-area {
        color: rgb(136, 136, 136);
        margin-top: 0.714rem;
        padding-bottom: 0.143rem;
    }

    @media print {
        html, body {
            border: 1px solid transparent;
            height: 99%;
            break-after: avoid;
            break-before: avoid;
        }

        .typora-export * {
            -webkit-print-color-adjust: exact;
        }

        h1, h2, h3, h4, h5, h6 {
            break-after: avoid-page;
            orphans: 2;
        }

        p {
            orphans: 4;
        }

        html.blink-to-pdf {
            font-size: 13px;
        }

        .typora-export #write {
            padding-left: 1cm;
            padding-right: 1cm;
            padding-bottom: 0px;
            break-after: avoid;
        }

        .typora-export #write::after {
            height: 0px;
        }

        @page {
            margin: 20mm 0mm;
        }
    }

    .footnote-line {
        margin-top: 0.714em;
        font-size: 0.7em;
    }

    a img, img a {
        cursor: pointer;
    }

    pre.md-meta-block {
        font-size: 0.8rem;
        min-height: 2.86rem;
        white-space: pre-wrap;
        background: rgb(204, 204, 204);
        display: block;
        overflow-x: hidden;
    }

    p .md-image:only-child {
        display: inline-block;
        width: 100%;
        text-align: center;
    }

    #write .MathJax_Display {
        margin: 0.8em 0px 0px;
    }

    .mathjax-block {
        white-space: pre;
        overflow: hidden;
        width: 100%;
    }

    p + .mathjax-block {
        margin-top: -1.143rem;
    }

    .mathjax-block:not(:empty)::after {
        display: none;
    }

    [contenteditable="true"]:active, [contenteditable="true"]:focus {
        outline: none;
        box-shadow: none;
    }

    .task-list {
        list-style-type: none;
    }

    .task-list-item {
        position: relative;
        padding-left: 1em;
    }

    .task-list-item input {
        position: absolute;
        top: 0px;
        left: 0px;
    }

    .math {
        font-size: 1rem;
    }

    .md-toc {
        min-height: 3.58rem;
        position: relative;
        font-size: 0.9rem;
        border-radius: 10px;
    }

    .md-toc-content {
        position: relative;
        margin-left: 0px;
    }

    .md-toc::after, .md-toc-content::after {
        display: none;
    }

    .md-toc-item {
        display: block;
        color: rgb(65, 131, 196);
        text-decoration: none;
    }

    .md-toc-inner:hover {
    }

    .md-toc-inner {
        display: inline-block;
        cursor: pointer;
    }

    .md-toc-h1 .md-toc-inner {
        margin-left: 0px;
        font-weight: bold;
    }

    .md-toc-h2 .md-toc-inner {
        margin-left: 2em;
    }

    .md-toc-h3 .md-toc-inner {
        margin-left: 4em;
    }

    .md-toc-h4 .md-toc-inner {
        margin-left: 6em;
    }

    .md-toc-h5 .md-toc-inner {
        margin-left: 8em;
    }

    .md-toc-h6 .md-toc-inner {
        margin-left: 10em;
    }

    @media screen and (max-width: 48em) {
        .md-toc-h3 .md-toc-inner {
            margin-left: 3.5em;
        }

        .md-toc-h4 .md-toc-inner {
            margin-left: 5em;
        }

        .md-toc-h5 .md-toc-inner {
            margin-left: 6.5em;
        }

        .md-toc-h6 .md-toc-inner {
            margin-left: 8em;
        }
    }

    a.md-toc-inner {
        font-size: inherit;
        font-style: inherit;
        font-weight: inherit;
        line-height: inherit;
    }

    .footnote-line a:not(.reversefootnote) {
        color: inherit;
    }

    .md-attr {
        display: none;
    }

    .md-fn-count::after {
        content: ".";
    }

    .md-tag {
        opacity: 0.5;
    }

    .md-comment {
        color: rgb(162, 127, 3);
        opacity: 0.8;
        font-family: monospace;
    }

    code {
        text-align: left;
    }

    h1 .md-tag, h2 .md-tag, h3 .md-tag, h4 .md-tag, h5 .md-tag, h6 .md-tag {
        font-weight: initial;
        opacity: 0.35;
    }

    a.md-print-anchor {
        border-width: initial !important;
        border-style: none !important;
        border-color: initial !important;
        display: inline-block !important;
        position: absolute !important;
        width: 1px !important;
        right: 0px !important;
        outline: none !important;
        background: transparent !important;
        text-decoration: initial !important;
        text-shadow: initial !important;
    }

    .md-inline-math .MathJax_SVG .noError {
        display: none !important;
    }

    .mathjax-block .MathJax_SVG_Display {
        text-align: center;
        margin: 1em 0em;
        position: relative;
        text-indent: 0px;
        max-width: none;
        max-height: none;
        min-height: 0px;
        min-width: 100%;
        width: auto;
        display: block !important;
    }

    .MathJax_SVG_Display, .md-inline-math .MathJax_SVG_Display {
        width: auto;
        margin: inherit;
        display: inline-block !important;
    }

    .MathJax_SVG .MJX-monospace {
        font-family: monospace;
    }

    .MathJax_SVG .MJX-sans-serif {
        font-family: sans-serif;
    }

    .MathJax_SVG {
        display: inline;
        font-style: normal;
        font-weight: normal;
        line-height: normal;
        zoom: 90%;
        text-indent: 0px;
        text-align: left;
        text-transform: none;
        letter-spacing: normal;
        word-spacing: normal;
        word-wrap: normal;
        white-space: nowrap;
        float: none;
        direction: ltr;
        max-width: none;
        max-height: none;
        min-width: 0px;
        min-height: 0px;
        border: 0px;
        padding: 0px;
        margin: 0px;
    }

    .MathJax_SVG * {
        transition: none;
    }

    .md-diagram-panel > svg {
        max-width: 100%;
    }

    [lang="flow"] svg, [lang="mermaid"] svg {
        max-width: 100%;
    }


    :root {
        --side-bar-bg-color: #fafafa;
        --control-text-color: #777;
    }

    @font-face {
        font-family: "Open Sans";
        font-style: normal;
        font-weight: normal;
        src: local("Open Sans Regular"), url("./github/400.woff") format("woff");
    }

    @font-face {
        font-family: "Open Sans";
        font-style: italic;
        font-weight: normal;
        src: local("Open Sans Italic"), url("./github/400i.woff") format("woff");
    }

    @font-face {
        font-family: "Open Sans";
        font-style: normal;
        font-weight: bold;
        src: local("Open Sans Bold"), url("./github/700.woff") format("woff");
    }

    @font-face {
        font-family: "Open Sans";
        font-style: italic;
        font-weight: bold;
        src: local("Open Sans Bold Italic"), url("./github/700i.woff") format("woff");
    }

    html {
        font-size: 16px;
    }

    body {
        font-family: "Open Sans", "Clear Sans", "Helvetica Neue", Helvetica, Arial, sans-serif;
        color: rgb(51, 51, 51);
        line-height: 1.6;
    }

    #write {
        max-width: 860px;
        margin: 0px auto;
        padding: 20px 30px 100px;
    }

    #write > ul:first-child, #write > ol:first-child {
        margin-top: 30px;
    }

    body > :first-child {
        margin-top: 0px !important;
    }

    body > :last-child {
        margin-bottom: 0px !important;
    }

    a {
        color: rgb(65, 131, 196);
    }

    h1, h2, h3, h4, h5, h6 {
        position: relative;
        margin-top: 1rem;
        margin-bottom: 1rem;
        font-weight: bold;
        line-height: 1.4;
        cursor: text;
    }

    h1:hover a.anchor, h2:hover a.anchor, h3:hover a.anchor, h4:hover a.anchor, h5:hover a.anchor, h6:hover a.anchor {
        text-decoration: none;
    }

    h1 tt, h1 code {
        font-size: inherit;
    }

    h2 tt, h2 code {
        font-size: inherit;
    }

    h3 tt, h3 code {
        font-size: inherit;
    }

    h4 tt, h4 code {
        font-size: inherit;
    }

    h5 tt, h5 code {
        font-size: inherit;
    }

    h6 tt, h6 code {
        font-size: inherit;
    }

    h1 {
        padding-bottom: 0.3em;
        font-size: 2.25em;
        line-height: 1.2;
        border-bottom: 1px solid rgb(238, 238, 238);
    }

    h2 {
        padding-bottom: 0.3em;
        font-size: 1.75em;
        line-height: 1.225;
        border-bottom: 1px solid rgb(238, 238, 238);
    }

    h3 {
        font-size: 1.5em;
        line-height: 1.43;
    }

    h4 {
        font-size: 1.25em;
    }

    h5 {
        font-size: 1em;
    }

    h6 {
        font-size: 1em;
        color: rgb(119, 119, 119);
    }

    p, blockquote, ul, ol, dl, table {
        margin: 0.8em 0px;
    }

    li > ol, li > ul {
        margin: 0px;
    }

    hr {
        height: 4px;
        padding: 0px;
        margin: 16px 0px;
        background-color: rgb(231, 231, 231);
        border-width: 0px 0px 1px;
        border-style: none none solid;
        border-top-color: initial;
        border-right-color: initial;
        border-left-color: initial;
        border-image: initial;
        overflow: hidden;
        box-sizing: content-box;
        border-bottom-color: rgb(221, 221, 221);
    }

    body > h2:first-child {
        margin-top: 0px;
        padding-top: 0px;
    }

    body > h1:first-child {
        margin-top: 0px;
        padding-top: 0px;
    }

    body > h1:first-child + h2 {
        margin-top: 0px;
        padding-top: 0px;
    }

    body > h3:first-child, body > h4:first-child, body > h5:first-child, body > h6:first-child {
        margin-top: 0px;
        padding-top: 0px;
    }

    a:first-child h1, a:first-child h2, a:first-child h3, a:first-child h4, a:first-child h5, a:first-child h6 {
        margin-top: 0px;
        padding-top: 0px;
    }

    h1 p, h2 p, h3 p, h4 p, h5 p, h6 p {
        margin-top: 0px;
    }

    li p.first {
        display: inline-block;
    }

    ul, ol {
        padding-left: 30px;
    }

    ul:first-child, ol:first-child {
        margin-top: 0px;
    }

    ul:last-child, ol:last-child {
        margin-bottom: 0px;
    }

    blockquote {
        border-left: 4px solid rgb(221, 221, 221);
        padding: 0px 15px;
        color: rgb(119, 119, 119);
    }

    blockquote blockquote {
        padding-right: 0px;
    }

    table {
        padding: 0px;
        word-break: initial;
    }

    table tr {
        border-top: 1px solid rgb(204, 204, 204);
        margin: 0px;
        padding: 0px;
    }

    table tr:nth-child(2n) {
        background-color: rgb(248, 248, 248);
    }

    table tr th {
        font-weight: bold;
        border: 1px solid rgb(204, 204, 204);
        text-align: left;
        margin: 0px;
        padding: 6px 13px;
    }

    table tr td {
        border: 1px solid rgb(204, 204, 204);
        text-align: left;
        margin: 0px;
        padding: 6px 13px;
    }

    table tr th:first-child, table tr td:first-child {
        margin-top: 0px;
    }

    table tr th:last-child, table tr td:last-child {
        margin-bottom: 0px;
    }

    .CodeMirror-gutters {
        border-right: 1px solid rgb(221, 221, 221);
    }

    .md-fences, code, tt {
        border: 1px solid rgb(221, 221, 221);
        background-color: rgb(248, 248, 248);
        border-radius: 3px;
        font-family: Consolas, "Liberation Mono", Courier, monospace;
        padding: 2px 4px 0px;
        font-size: 0.9em;
    }

    .md-fences {
        margin-bottom: 15px;
        margin-top: 15px;
        padding: 8px 1em 6px;
    }

    .task-list {
        padding-left: 0px;
    }

    .task-list-item {
        padding-left: 32px;
    }

    .task-list-item input {
        top: 3px;
        left: 8px;
    }

    @media screen and (min-width: 914px) {
    }

    @media print {
        html {
            font-size: 13px;
        }

        table, pre {
            break-inside: avoid;
        }

        pre {
            word-wrap: break-word;
        }
    }

    .md-fences {
        background-color: rgb(248, 248, 248);
    }

    #write pre.md-meta-block {
        padding: 1rem;
        font-size: 85%;
        line-height: 1.45;
        background-color: rgb(247, 247, 247);
        border: 0px;
        border-radius: 3px;
        color: rgb(119, 119, 119);
        margin-top: 0px !important;
    }

    .mathjax-block > .code-tooltip {
        bottom: 0.375rem;
    }

    #write > h3.md-focus::before {
        left: -1.5625rem;
        top: 0.375rem;
    }

    #write > h4.md-focus::before {
        left: -1.5625rem;
        top: 0.285714rem;
    }

    #write > h5.md-focus::before {
        left: -1.5625rem;
        top: 0.285714rem;
    }

    #write > h6.md-focus::before {
        left: -1.5625rem;
        top: 0.285714rem;
    }

    .md-image > .md-meta {
        border: 1px solid rgb(221, 221, 221);
        border-radius: 3px;
        font-family: Consolas, "Liberation Mono", Courier, monospace;
        padding: 2px 4px 0px;
        font-size: 0.9em;
        color: inherit;
    }

    .md-tag {
        color: inherit;
    }

    .md-toc {
        margin-top: 20px;
        padding-bottom: 20px;
    }

    .sidebar-tabs {
        border-bottom: none;
    }

    #typora-quick-open {
        border: 1px solid rgb(221, 221, 221);
        background-color: rgb(248, 248, 248);
    }

    #typora-quick-open-item {
        background-color: rgb(250, 250, 250);
        border-color: rgb(254, 254, 254) rgb(229, 229, 229) rgb(229, 229, 229) rgb(238, 238, 238);
        border-style: solid;
        border-width: 1px;
    }

    #md-notification::before {
        top: 10px;
    }

    .on-focus-mode blockquote {
        border-left-color: rgba(85, 85, 85, 0.12);
    }

    header, .context-menu, .megamenu-content, footer {
        font-family: "Segoe UI", Arial, sans-serif;
    }

    .file-node-content:hover .file-node-icon, .file-node-content:hover .file-node-open-state {
        visibility: visible;
    }

    .mac-seamless-mode #typora-sidebar {
        background-color: var(--side-bar-bg-color);
    }

    .md-lang {
        color: rgb(180, 101, 77);
    }


    </style>
</head>
<body class='typora-export'>
<div id='write' class='is-node'>
    <b><a name='header-n0' class='md-header-anchor '></a>对象循环依赖问题</b>

    <b><a name='header-n1' class='md-header-anchor '></a>1、java对象之间的循环依赖</b><br>
    <pre class='md-fences mock-cm' style='display:block;position:relative'>
        1.  一个对象可以委托另外一个对象去处理某些功能，这种水平扩展当前对象功能的方式我们称之为委托机制。
        2.  委托机制也常被称为注入、依赖等概念。
        3.  A对象委托B对象去处理某些功能，就认为是A委托B去处理某些事情、A对象注入了对B对象的依赖、A对象依赖B对象去处理某些事情等，含义是相同的，都代表委托机制。
        4.  循环依赖指的是java对象之间互相彼此依赖对方的现象，比如A对象依赖B，B对象依赖C，C对象又依赖A。
        5.  循环依赖不一定会导致问题，主要看循环依赖的方式。
        6.  如果循环依赖一旦产生StackOverflowError栈内存溢出的现象，其根本原因是因为对象循环依赖之间产生了无限循环，而不是一次性的循环闭环。
    </pre>
    <b><a name='header-n2' class='md-header-anchor '></a>2、详解循环依赖</b><br>
    <b><a name='header-n21' class='md-header-anchor '></a>2.1、 什么是循环依赖？</b>
    <pre class='md-fences mock-cm' style='display:block;position:relative'>
        A对象依赖B，B对象又依赖A，则称A和B对象循环依赖。
        A对象依赖B，B对象依赖C，C对象依赖D，D对象又依赖A，则称A、B、C、D四个对象循环依赖。
        其他对象之间构成循环闭环的，以此类推。
        所以，即两个或两个以上的Bean互相持有对方的引用，最终形成闭环，这种情况就称bean之间形成了循环依赖。
    </pre>
    <b><a name='header-n22' class='md-header-anchor '></a>2.2、 如何检测是否发生了循环依赖？</b>
    <pre class='md-fences mock-cm' style='display:block;position:relative'>
        如果你是一个框架设计者，你在整个系统中如何检测某个bean和其他bean发生了循环依赖呢？
        1.  使用一个列表去缓存正在创建中的bean。
        2.  bean创建之前，先去缓存中查询是否存在该bean的记录。
        3.  如果缓存中不存在，说明没有创建过该bean，则将该beanName记录到该缓存中，bean创建完成后再从该缓存中移除。
        4.  如果缓存中已经存在该bean，说明该bean存在缓存依赖。
        <font color="#a52a2a">
            tips：
            纯java中，遇到循环依赖，jdk层面并没有做任何检测，而是最后导致了栈内存溢出，直接抛出 StackOverflowError 异常。
            我们明知道一旦产生循环依赖，jdk底层一定会导致StackOverflowError异常，因此，如果作为一个框架设计者，当我们遇到循环依赖场景时，应该及时检测到，抛出某种自定义的异常。
            <b>而不是任由循环依赖一直消耗栈内存直到栈内存溢出！</b>
            及时检测及时止损很重要！后面介绍的spring就实现了对循环依赖的检测方案。
        </font>
    </pre>
    <b><a name='header-n23' class='md-header-anchor '></a>2.3、 循环依赖的方式</b>
    <pre class='md-fences mock-cm' style='display:block;position:relative'>
        我们知道，一个Java对象依赖另外一个java对象去增强自身的功能，此时，另外一个java对象可以作为这个对象的一个成员变量存在，也可以作为这个对象的一个方法变量存在；大多数情况下都是作为成员变量存在的。
        1.  向A对象注入B对象，B对象作为A对象的一个成员，采用构造方法的方式直接注入。
        2.  向A对象注入B对象，B对象作为A对象的一个成员，采用属性设置的方式间接注入。

        构造方法直接注入的案例如下：
            public ClassA(){
                this.classB = new ClassB();
            }

        属性设置注入的案例如下：
            ClassA a = new ClassA();
            ClassB b = new ClassB();
            a.setClassB(b);

        3.  按照循环依赖的方式，我们将循环依赖分为两种：构造器的循环依赖、属性的循环依赖。
    </pre>
    <b><a name='header-n24' class='md-header-anchor '></a>2.4、 循环依赖导致的问题</b>
    <pre class='md-fences mock-cm' style='display:block;position:relative'>
        1.  构造器的循环依赖一定会导致StackOverflowError栈内存溢出的现象，并且无法解决。
        JVM装载一个目标类的流程是”加载、链接、初始化“，具体体现在代码上的流程就是”静、静、非、构、构、初始化方法“。
        如果直接通过构造方法向A对象注入B对象，同时也向B对象注入A对象。如下所示：
        A的构造方法实现如下：
            public ClassA(){
                this.classB = new ClassB();
            }

        B的构造方法实现如下：
            public ClassB(){
                this.classA = new ClassA();
            }

        那么，当JVM开始装载类A，装载流程执行到“静、静、非、构、构、初始化方法”中的“构造方法”这一步骤时，即开始执行ClassA的构造方法时，发现A类又主动引用了类B，因此又开始装载类B。
        这时，A类没有装载完成。
        同理，当类B执行到“静、静、非、构、构、初始化方法”中的“构造方法”这一步骤时，即开始执行ClassB的构造方法时，发现B类又主动引用了类A，因此又开始重新装载类A。
        这时，B类没有装载完成。
        然后JVM重新装载类A，又重新装载类B。
        如此反复，彼此循环执行构造器。
        JVM每执行一次构造方法，都会将为当前类对象申请的引用地址进行入栈操作；因此，构造器的循环依赖导致JVM循环的为A对象和B对象申请内存地址并进行入栈操作，最终导致栈内存溢出。
        最终造成StackOverflowError栈内存溢出的现象。

        “静、静、非、构、构、初始化方法”这几步中，开发人员可控制的步骤只有最后一个“初始化方法”。
        “初始化方法”这一步实际上是开发人员主动为已经实例化好的目标对象显式地进行各种属性的初始化动作。开发人员调用则调用，不调用则不会调用。
        而“静、静、非、构、构”这几步，一旦编写，则JVM会自动按照顺序调用，开发人员无法决定JVM的调用行为。
        因此，构造器的循环依赖，因为每次都会在JVM调用构造器执行构造方法时循环的为相互依赖的对象申请内存并入栈，所以JVM的行为，外界无法干预，即构造器的循环依赖无法解决。

        2.  属性的循环依赖有可能会导致StackOverflowError栈内存溢出的现象，但是有方法去解决。
        首先给出结论：属性的循环依赖分为两种，一种是要获取的对象是单例；一种是要获取的对象是多例。单例的属性循环依赖完全可以避免StackOverflowError，但多例的属性循环依赖无法避免StackOverflowError。
        因此：我们能解决的循环依赖，往往是指单例的属性循环依赖。
    </pre>
    <b><a name='header-n25' class='md-header-anchor '></a>2.5、 构造器的循环依赖案例</b>
    <pre class='md-fences mock-cm' style='display:block;position:relative'>
        <font color="#a52a2a">ClassA</font>
        package zeh.test.demo.com.xunhuanyilai;

        /**
         * 功能描述 java中循环依赖
         *
         * @since 2021-03-09
         */
        public class ClassA {
            private ClassB classB;

            public ClassA(){
                this.classB = new ClassB();
            }

            public void testA(){
                System.out.println("Class A");
            }
        }

        <font color="#a52a2a">ClassB</font>
        package zeh.test.demo.com.xunhuanyilai;

        /**
         * 功能描述 Java中循环依赖
         *
         * @since 2021-03-09
         */
        public class ClassB {
            private ClassA classA;

            public ClassB(){
                this.classA = new ClassA();
            }

            public void testB(){
                System.out.println("class B");
            }
        }

        <font color="#a52a2a">Main</font>
        package zeh.test.demo.com.xunhuanyilai;

        /**
         * 功能描述
         *
         * @since 2021-03-09
         */
        public class Main {
            public static void main(String[] args) {
                ClassA a = new ClassA();
                ClassB b = new ClassB();
                a.testA();
                b.testB();
            }
        }

        <font color="#a52a2a">结论</font>
        构造器的循环依赖完全由JVM控制，开发人员无法控制对象依赖的循环关系，因此一定会发生StackOverflowError异常。
    </pre>
    <b><a name='header-n26' class='md-header-anchor '></a>2.6、 单例的属性循环依赖案例</b>
    <pre class='md-fences mock-cm' style='display:block;position:relative'>
        <font color="#a52a2a">ClassA</font>
        package zeh.test.demo.com.xunhuanyilai2;

        /**
         * 功能描述 java中循环依赖
         *
         * @since 2021-03-09
         */
        public class ClassA {
            private ClassB classB;

            // 空构造。
            public ClassA() {
            }

            public ClassB getClassB() {
                return classB;
            }

            public void setClassB(ClassB classB) {
                this.classB = classB;
            }

            public void testA() {
                System.out.println("Class A");
            }
        }

        <font color="#a52a2a">ClassB</font>
        package zeh.test.demo.com.xunhuanyilai2;

        /**
         * 功能描述 Java中循环依赖
         *
         * @since 2021-03-09
         */
        public class ClassB {
            private ClassA classA;

            // 空构造。
            public ClassB() {
            }

            public ClassA getClassA() {
                return classA;
            }

            public void setClassA(ClassA classA) {
                this.classA = classA;
            }

            public void testB() {
                System.out.println("class B");
            }
        }

        <font color="#a52a2a">Main</font>
        package zeh.test.demo.com.xunhuanyilai2;

        /**
         * 功能描述
         *
         * @since 2021-03-09
         */
        public class Main {
            public static void main(String[] args) {

                // 只依赖空构造实例化对象，并不利用构造去设置属性值。
                // 提前实例化好所有的对象，至于依赖关系后续再进行注入。
                // 此处我们是硬编码实现的单例，只要我们只产生一个ClassA和一个ClassB，那么这时候这两个对象就是单例。
                ClassA a = new ClassA();
                ClassB b = new ClassB();

                // 实例化好对象后，再去设置对象的依赖关系。
                a.setClassB(b);
                b.setClassA(a);
                a.testA();
                b.testB();
            }
        }

        <font color="#a52a2a">结论</font>
        单例的属性循环依赖，首先，属性的循环依赖完全将JVM调用构造器实例化对象和对对象属性的设置这两个操作进行了分离，因此是否设置对象彼此的依赖关系完全取决于开发者。
        其次，当构造器构造出一个空对象时，因为该对象要求是单例，因此构造器只会构造这一次，这就保证了该对象一定是会提前暴露出来的。无论对于A、B对象而言，都是单例的，都会提前暴露。
        既然提前暴露了，便可以在后续进行彼此依赖关系的设置。
        比如 b.setClassA(a);就是因为a对象提前暴露了它的引用，并将引用传递给了b对象中的classA属性了。
        故：单例的属性循环依赖不会产生StackOverflowError栈内存溢出的现象，因为它们通过提前暴露对象的引用并进行引用传递，已经让彼此的依赖并不是无限循环方式了。
    </pre>
    <b><a name='header-n27' class='md-header-anchor '></a>2.7、 多例的属性循环依赖案例</b>
    <pre class='md-fences mock-cm' style='display:block;position:relative'>
        <font color="#a52a2a">ClassA</font>
        package zeh.test.demo.com.xunhuanyilai3;

        /**
         * 功能描述 java中循环依赖
         *
         * @since 2021-03-09
         */
        public class ClassA {
            private ClassB classB;

            // 空构造。
            public ClassA() {
            }

            public ClassB getClassB() {
                return classB;
            }

            public void setClassB(ClassB classB) {
                this.classB = classB;
            }

            public void testA() {
                System.out.println("Class A");
            }
        }

        <font color="#a52a2a">ClassB</font>
        package zeh.test.demo.com.xunhuanyilai3;

        /**
         * 功能描述 Java中循环依赖
         *
         * @since 2021-03-09
         */
        public class ClassB {
            private ClassA classA;

            // 空构造。
            public ClassB() {
            }

            public ClassA getClassA() {
                return classA;
            }

            public void setClassA(ClassA classA) {
                this.classA = classA;
            }

            public void testB() {
                System.out.println("class B");
            }
        }

        <font color="#a52a2a">Main</font>
        package zeh.test.demo.com.xunhuanyilai3;

        /**
         * 功能描述
         *
         * @since 2021-03-09
         */
        public class Main {
            public static void main(String[] args) {
                ClassA classA = new ClassA();
                fillProperties(classA);
            }

            public static void fillProperties(ClassA a) {
                // 只依赖空构造实例化对象，并不利用构造去设置属性值。
                // 如果是延迟加载的多例，则对象是即时产生的，需要就会产生，而且每次都需要产生一个全新的对象。
                // 因此当需要a时，就必须将a进行实例化好并且设置好a的所有属性依赖。
                if (a.getClassB() == null) {
                    ClassB b = new ClassB();
                    // 当a实例化好后需要设置b时，发现没有b，因此产生一个全新的b
                    a.setClassB(b);
                    if (b.getClassA() == null) {
                        ClassA a1 = new ClassA();
                        // 当b实例化好后需要设置a时，发现没有a，因此产生一个全新的a1，如此反复，将不停的产生新的对象。
                        b.setClassA(a1);
                        fillProperties(a1);
                    }
                }
            }
        }

        <font color="#a52a2a">结论</font>
        多例的属性循环依赖，因为多例要求每次产生对象都必须是全新的对象，所以，当产生A对象时，发现A需要注入B，那么就会产生一个B对象；
        当产生B对象时，又发现B对象需要注入A，那么就又会产生一个新的A对象（此时刚开始产生的A对象不能使用，因为此时产生的B对象要求是全新的，那么B对象里面的所有内容都必须是新产生的而不能是之前产生的），如此反复，最终导致StackOverflowError异常。
    </pre>
    <b><a name='header-n28' class='md-header-anchor '></a>2.8、 总结循环依赖</b>
    <pre class='md-fences mock-cm' style='display:block;position:relative'>
        循环依赖一旦形成的无限循环依赖方式，则一定产生StackOverflowError栈内存溢出。
        如果循环依赖只是形成闭环，则一定不会产生StackOverflowError栈内存溢出。
    </pre>
    <b><a name='header-n3' class='md-header-anchor '></a>3、spring处理循环依赖</b><br>
    <b><a name='header-n31' class='md-header-anchor '></a>3.1、 宏观方案</b>
    <pre class='md-fences mock-cm' style='display:block;position:relative'>
        查看spring的源码，得出如下结论：
        1.  当前bean交给spring的IOC容器进行管理，如果依赖其他bean，当其他bean的注入方式是通过构造器进行注入的，那么spring启动将报错，即spring无法处理构造器的循环依赖。
        2.  当前bean如果注入其他bean是通过属性注入或者setter注入（本质都是属性注入的），如果当前bean是单例管理的，那么spring通过三级缓存来处理循环依赖。
        3.  当前bean注入其他bean，如果当前bean是多例管理的，那么spring无法处理循环依赖。
    </pre>
    <b><a name='header-n32' class='md-header-anchor '></a>3.2、 spring如何检测目标bean存在循环依赖？</b>
    <pre class='md-fences mock-cm' style='display:block;position:relative'>
        <font color="gray">
            1.  spring扫描到需要实例化目标bean；
            2.  spring去ioc容器中获取bean，获取不到；
            3.  spring去单例bean的缓存中获取bean，获取不到；
            4.  spring开始创建bean；
            5.  创建前首先去正在创建的bean列表中尝试加入当前bean，如果加入失败，说明当前bean正在被创建，即发生了循环依赖，直接报异常；
            6.  如果可以加入当前bean到正在创建的bean列表中，则说明当前bean不存在循环依赖，继续执行bean创建；
            7.  开始创建bean，先去三级缓存中获取bean，获取不到，则创建；
            8.  反射目标bean的无参构造去创建bean实例；
            9.  填充目标bean的各种属性；
            10. 执行目标bean的初始化方法；
            11. 从正在创建的bean列表中，删除该bean；
            12. 缓存目标bean到bean缓存中，即加入到ioc容器中。
        </font>

        关键步骤是5和11。
        即spring通过一个缓存列表，来存储每一个正在创建的bean对象。
        在开始创建bean对象前，就尝试加入该bean；
        当该bean被完整创建成功后（实例化、填充完属性、初始化），则从该缓存列表中移除该bean。
        因此，spring在创建bean之前，通过检测“正在创建的bean缓存列表”中是否包含当前bean，来检测当前bean是否产生了循环依赖。

        需要注意的是，spring只要检测到目标bean存在循环依赖，就会直接抛出异常。
        <font color="#a52a2a">
            tips：
            spring为啥要检测循环依赖？
            前面说过，对于java来说如果不检测循环依赖，任由jvm去搞的话，最终会导致StackOverflowError，即栈内存溢出的。
            因此，作为一个框架，就需要及时发现循环依赖，及时止损，而不是非得耗尽栈内存！
        </font>
    </pre>
    <b><a name='header-n33' class='md-header-anchor '></a>3.3、 spring如何解决循环依赖？</b>
    <pre class='md-fences mock-cm' style='display:block;position:relative'>
        <b><font color="#a52a2a">先了解spring创建bean的几个步骤</font></b>
        spring实际上是在java基础之上，对任何一个目标bean的创建制定了自己的标准。
        这个标准分为如下3个步骤：
        <font color="gray">
            1.  实例化bean，即通过反射调用目标bean的构造方法去创建目标bean实例；如果自己交给spring管理的bean的构造方法是无参构造，则spring默认调用无参构造，如果是有参构造，则spring默认调用有参构造。这个时候spring创建出来的bean往往是通过无参构造去实例化的，因为后续有填充属性这一步，因此这一步产生的bean一般是空构造产生的空bean对象，我们称之为早期bean。
            2.  填充属性；为实例化好的目标bean填充该bean依赖的属性；即@Autowired注入的属性，底层是反射目标bean的setXXX方法进行属性填充。
            3.  bean的初始化操作；比如目标bean定义了init()方法，则spring在为目标bean填充完属性之后，再执行init方法对bean做某些初始化操作。此时bean经过了层层处理，是最终bean。
        </font>

        通过上面两个步骤，可以得知，要想为目标bean注入依赖对象，有两种方式：
        1.  通过步骤1，直接调用目标bean的有参构造为目标bean注入依赖对象。
        2.  通过步骤2，在为目标bean填充属性时，注入依赖对象。

        <b><font color="#a52a2a">spring通过构造器注入依赖对象</font></b>
        构造器注入依赖对象，一旦产生循环依赖，spring无法解决。本质是构造器的行为是JVM自己控制的，不受外部控制。
        以下是spring通过构造器注入循环依赖的简化步骤：
        <font color="gray">
            1.  spring实例化serviceA，实例化前将serviceA的beanName放入正在创建的bean列表中缓存起来。
            2.  调用构造器实例化serviceA，发现serviceA依赖serviceB。
            3.  spring又开始实例化serviceB,实例化前将serviceB的beanName放入正在创建的bean列表中缓存起来。
            4.  调用构造器实例化serviceB，发现serviceB又依赖serviceA（此处即发生了循环依赖）。
            5.  调用构造器实例化serviceA，结果发现serviceA已经存在于正在创建的bean列表中了，于是抛出spring自定义的异常。
        </font>

        <b><font color="#a52a2a">spring通过属性或者setter方式注入依赖对象</font></b>
        对于单例bean，如果是我们自己硬编码的话，那肯定如下：
        ClassA a = new ClassA();
        ClassB b = new ClassB();
        即，硬编码方式只要开发者自己保证在整个过程中只手动new一次对象即可称之为单例。
        注意：
        此处的单例实际上不同于我们一般说的单例模式那种单例，单例模式那种单例是站在JVM角度保证的单例，而不是站在业务角度保证的单例。
        也就是说，我们在实现单例时，只要能保证在整个JVM生命周期中，由我们自己产生的实例只有唯一一个，就认为我们的实现保证了单例。

        那如果是spring容器要产生单例bean呢？
        由于单例bean在spring容器中只存在一个，即只要是单例bean交给spring去管理，那spring就要保证通过它管理的单例bean在整个JVM生命周期中只能产生一个。
        因此，spring容器中肯定是有一个缓存来存放所有已经创建好的单例bean；
        获取单例bean前，先去缓存中查找，找到了就直接返回；找不到的话再去创建，创建完毕之后再将其丢到缓存中。
        可以使用一个map来缓存单例bean，比如使用下面这个：
        <b>Map&lt;String,Object&gt; singletonObjects = new ConcurrentHashMap&lt;&gt;(256);</b>

        下面我们来猜测一下spring创建循环依赖的两个对象serviceA和serviceB的大致步骤：
        <font color="gray">
            1.  spring轮询准备创建2个bean：serviceA和serviceB。
            2.  spring发现singletonObjects缓存中没有serviceA。
            3.  spring反射调用serviceA的构造器创建serviceA的实例。
            4.  spring准备为serviceA填充属性，发现serviceA依赖serviceB，需要通过setServiceB注入serviceB。
            5.  serviceA向spring容器查找serviceB。
            6.  spring发现singletonObjects缓存中没有serviceB。
            7.  spring反射调用serviceB的构造器创建serviceB的实例。
            8.  spring准备为serviceB填充属性，发现serviceB又依赖serviceA，需要通过setServiceA注入serviceA。
            9.  serviceB向spring容器查找serviceA。
            10. 此时又进入第2步了。
        </font>
        what？上面的过程死循环了，怎么才能终结循环？
        可以在第2步和第7步后加一个操作：将实例化好的serviceA和serviceB加入到singletonObjects缓存中，此时这个问题就解决了。

        spring也采用类似的方式，只是稍微复杂了些。上面使用了一个缓存singletonObjects，而spring使用了三个缓存来解决这种单例bean的存储问题。
        这3个缓存就是我们常说的spring管理bean的三级缓存。
        <b>
            spring三级缓存对应的代码如下：
            // 第一级缓存：最终单例bean的缓存
            Map&lt;String,Object&gt; singletonObjects = new ConcurrentHashMap&lt;&gt;(256);

            // 第二级缓存：早期暴露的bean的缓存
            Map&lt;String,Object&gt; earlySingletonObjects = new HashMap&lt;&gt;(16);

            // 第三级缓存：单例bean工厂的缓存
            // 注意，此处的第三级缓存本质上缓存的是一个可以创建bean实例的工厂，即一个ObjectFactory对象。
            // 该工厂实际上是个回调接口，其中只有一个方法 ：T getObject() throws BeansException。
            // 该方法的实现通过外部传入，即lambda表达式传入。
            // 该方法的实现很复杂，一般来说ObjectFactory对象中会缓存之前创建好的bean实例，如果能够拿到ObjectFactory，就会直接返回bean实例。
            // 否则，ObjectFactory重新创建bean。
            // 由此可见，三级缓存不直接缓存早期bean实例，而是直接缓存了bean工厂，目的就是让缓存的对象具备的功能更丰富。
            Map&lt;String,ObjectFactory&lt;?&gt;&gt; singletonFactories = new HashMap&lt;&gt;(16);
        </b>

        以下是spring创建一个单例bean的简化步骤，先不考虑依赖其他bean的情况：
        <font color="gray">
            1.  spring从Ioc容器中查询目标bean service，先从三级缓存（第一级缓存、第二级缓存、第三级缓存）中依次查询。
            2.  如果缓存中查询到了则直接返回service，查询不到则开始创建bean。
            3.  创建前首先去正在创建的bean列表中尝试加入当前bean，如果加入失败，说明当前bean正在被创建，即发生了循环依赖，直接报异常。
            4.  否则开始创建，spring实例化前将service的beanName放入正在创建的bean缓存列表中缓存起来。
            5.  spring调用空构造器实例化service对象，此时获得service的早期对象，service还未填充属性，未进行任何初始化操作。
            6.  将早期的service对象暴露给第三级缓存singletonFactories，进行缓存。
            7.  对service对象进行属性填充操作和初始化操作等后续操作，此时的service对象已经是最终的完整对象。
            8.  将service对象从正在创建的bean缓存列表中移除。
            9.  将service对象放入第一级缓存singletonObjects中，并且从第二级缓存earlySingletonObjects和第三级缓存singletonFactories中删除。
        </font>

        当A对象依赖B对象时，spring创建的简化步骤如下：
        <font color="gray">
            1.  spring从Ioc容器中查询目标bean serviceA，先从三级缓存（第一级缓存、第二级缓存、第三级缓存）中依次查询。
            2.  如果缓存中查询到了则直接返回serviceA，查询不到则开始创建bean。
            3.  创建前首先去正在创建的bean列表中尝试加入当前bean，如果加入失败，说明当前bean正在被创建，即发生了循环依赖，直接报异常。
            3.  否则开始创建，spring实例化前将serviceA的beanName放入正在创建的bean缓存列表中缓存起来。
            4.  spring调用空构造器实例化serviceA对象，此时获得serviceA的早期对象，serviceA还未填充属性，未进行任何初始化操作。
            5.  将早期的serviceA对象暴露给第三级缓存singletonFactories，进行缓存。
            6.  对serviceA对象进行属性填充操作和初始化操作等后续操作时，发现serviceA对象依赖serviceB对象。
            7.  spring从Ioc容器中查询目标bean serviceB，先从三级缓存（第一级缓存、第二级缓存、第三级缓存）中依次查询。
            8.  如果缓存中查询到了则直接返回serviceB，查询不到则开始创建bean。
            9.  创建前首先去正在创建的bean列表中尝试加入当前bean，如果加入失败，说明当前bean正在被创建，即发生了循环依赖，直接报异常。
            10.  否则开始创建，spring实例化前将serviceB的beanName放入正在创建的bean缓存列表中缓存起来。
            11. spring调用空构造器实例化serviceB对象，此时获得serviceB的早期对象，serviceB还未填充属性，未进行任何初始化操作。
            12. 将早期的serviceB对象暴露给第三级缓存singletonFactories，进行缓存。
            13. 对serviceB对象进行属性填充操作和初始化操作等后续操作，此时的serviceB对象已经是最终的完整对象。
            14. 将serviceB对象从正在创建的bean缓存列表中移除。
            15. 将serviceB对象放入第一级缓存singletonObjects中，并且从第二级缓存earlySingletonObjects和第三级缓存singletonFactories中删除。
            16. 返回创建好的serviceB对象给serviceA，可以对serviceA对象进行属性填充操作和初始化操作等后续操作，此时的serviceA对象已经是最终的完整对象。
            17. 将serviceA对象从正在创建的bean缓存列表中移除。
            18. 将serviceA对象放入第一级缓存singletonObjects中，并且从第二级缓存earlySingletonObjects和第三级缓存singletonFactories中删除。
        </font>
        <font color="#a52a2a">
            tips：
            分析上述步骤，发现，当两个对象或者多个对象之间没有产生循环依赖时，spring实际上并不会从三级缓存和二级缓存中获取对象。
            因为没有发生循环依赖，所以整个依赖链上的对象最终都是完整产生出来的，直接从第一级缓存中获取完整对象注入即可。
        </font>

        当A对象依赖B对象，B对象又依赖A对象时（即发生循环依赖），spring创建的简化步骤如下：
        <font color="gray">
            1.  spring从Ioc容器中查询目标bean serviceA，先从三级缓存（第一级缓存、第二级缓存、第三级缓存）中依次查询。
            2.  如果缓存中查询到了则直接返回serviceA，查询不到则开始创建bean。
            3.  创建前首先去正在创建的bean列表中尝试加入当前bean，如果加入失败，说明当前bean正在被创建，即发生了循环依赖，直接报异常。
            4.  否则开始创建，spring实例化前将serviceA的beanName放入正在创建的bean缓存列表中缓存起来。
            5.  spring调用空构造器实例化serviceA对象，此时获得serviceA的早期对象，serviceA还未填充属性，未进行任何初始化操作。
            6.  将早期的serviceA对象暴露给第三级缓存singletonFactories，进行缓存。
            7.  对serviceA对象进行属性填充操作和初始化操作等后续操作时，发现serviceA对象依赖serviceB对象。
            8.  spring从Ioc容器中查询目标bean serviceB，先从三级缓存（第一级缓存、第二级缓存、第三级缓存）中依次查询。
            9.  如果缓存中查询到了则直接返回serviceB，查询不到则开始创建bean。
            10. 创建前首先去正在创建的bean列表中尝试加入当前bean，如果加入失败，说明当前bean正在被创建，即发生了循环依赖，直接报异常。
            11. 否则开始创建，spring实例化前将serviceB的beanName放入正在创建的bean缓存列表中缓存起来。
            12. spring调用空构造器实例化serviceB对象，此时获得serviceB的早期对象，serviceB还未填充属性，未进行任何初始化操作。
            13. 将早期的serviceB对象暴露给第三级缓存singletonFactories，进行缓存。
            14. 对serviceB对象进行属性填充操作和初始化操作等后续操作时，发现serviceB对象又依赖serviceA对象。
            15. spring从Ioc容器中查询目标bean serviceA，先从三级缓存（第一级缓存、第二级缓存、第三级缓存）中依次查询。结果从第三级缓存中查询到了serviceA，于是将serviceA从第三级缓存singletonFactories中删除，移动到了第二级缓存earlySingletonObjects中。
            16. 将serviceA对象返回给serviceB对象，可以对serviceB对象进行属性填充操作和初始化操作等后续操作，此时的serviceA对象是早期对象，serviceB对象已经是完整对象了。
            17. 将serviceB对象从正在创建的bean缓存列表中移除。
            18. 将serviceB对象放入第一级缓存singletonObjects中，并且从第二级缓存earlySingletonObjects和第三级缓存singletonFactories中删除。
            19. 返回创建好的serviceB对象给serviceA，可以对serviceA对象进行属性填充操作和初始化操作等后续操作，此时的serviceA对象已经是最终的完整对象。因为此时serviceA已经完整了，所以前面serviceB持有的serviceA的早期引用也已经变成了完整对象了。
            20. 将serviceA对象从正在创建的bean缓存列表中移除。
            21. 将serviceA对象放入第一级缓存singletonObjects中，并且从第二级缓存earlySingletonObjects和第三级缓存singletonFactories中删除。
        </font>
        <font color="#a52a2a">
            tips：
            分析上述步骤，发现，当两个对象或者多个对象之间产生循环依赖时，spring会从第三级缓存中获取早期bean的引用然后存储在二级缓存中，并返回给依赖的对象。
            也就是说，只有发生了循环依赖后，才会查询三级缓存和二级缓存。
            如果整个依赖链上没有发生循环依赖，是不会查询三级缓存和二级缓存的，而是直接查询的最终bean所在的一级缓存。
        </font>
    </pre>
    <b><a name='header-n34' class='md-header-anchor '></a>3.4、 spring无法解决的循环依赖</b>
    <pre class='md-fences mock-cm' style='display:block;position:relative'>
        上面已经分析，对于构造器注入的循环依赖，spring无法解决。
        spring只能解决单例bean的循环依赖问题。
        <font color="#a52a2a">
            只有单例的bean对象会通过三级缓存提前暴露早期bean对象来解决循环依赖的问题。
            而非单例的bean，每次spring从容器中获取都是直接创建一个新的对象，每次都会重新创建，所以非单例的bean是没有任何缓存的，并且都是延迟加载的，即getBean的时候才会直接创建，而不是提前缓存。
            因此，所有非单例的bean都不会放入到三级缓存中（因为没有缓存放个毛啊），故spring无法解决非单例bean的循环依赖问题。
        </font>

        既然如此，就产生了几种情况需要注意。
        同样按照两个bean：serviceA和serviceB。

        <font color="#a52a2a">情况1：serviceA多例，serviceB多例</font>
        使用构造器构造器注入循环依赖，相互注入会直接报错。

        使用属性注入循环依赖，spring创建的简化步骤如下：
        <font color="gray">
            1.  因为serviceA是多例，当应用调用getBean()时，spring直接去创建serviceA。
            3.  创建前首先去正在创建的bean列表中尝试加入当前bean，如果加入失败，说明当前bean正在被创建，即发生了循环依赖，直接报异常。
            4.  否则开始创建，spring实例化前将serviceA的beanName放入正在创建的bean缓存列表中缓存起来。
            5.  spring调用空构造器实例化serviceA对象，此时获得serviceA的早期对象，serviceA还未填充属性，未进行任何初始化操作。
            7.  对serviceA对象进行属性填充操作和初始化操作等后续操作时，发现serviceA对象依赖serviceB对象。
            8.  因为serviceB也是多例，spring直接去创建serviceB。
            10. 创建前首先去正在创建的bean列表中尝试加入当前bean，如果加入失败，说明当前bean正在被创建，即发生了循环依赖，直接报异常。
            11. 否则开始创建，spring实例化前将serviceB的beanName放入正在创建的bean缓存列表中缓存起来。
            12. spring调用空构造器实例化serviceB对象，此时获得serviceB的早期对象，serviceB还未填充属性，未进行任何初始化操作。
            14. 对serviceB对象进行属性填充操作和初始化操作等后续操作时，发现serviceB对象又依赖serviceA对象。
            15. 因为serviceA是多例，每次都需要创建一个新的serviceA，于是spring又开始重新创建serviceA。
            16. 创建前首先去正在创建的bean列表中尝试加入当前bean，如果加入失败，说明当前bean正在被创建，即发生了循环依赖，直接报异常。很明显到这一步，因为前面已经将serviceA加入到正在创建的bean列表中了，因此spring此处检测到了循环依赖，直接抛出异常了。
        </font>

        <font color="#a52a2a">情况2：serviceA单例，serviceB多例，应用直接获取serviceB</font>
        使用构造器构造器注入循环依赖，相互注入会直接报错。

        使用属性注入循环依赖，spring创建的简化步骤如下：
        <font color="gray">
            1.  因为serviceB是多例，当应用调用getBean()时，spring直接去创建serviceB。
            2.  创建前首先去正在创建的bean列表中尝试加入当前bean，如果加入失败，说明当前bean正在被创建，即发生了循环依赖，直接报异常。
            3.  否则开始创建，spring实例化前将serviceB的beanName放入正在创建的bean缓存列表中缓存起来。
            4.  spring调用空构造器实例化serviceB对象，此时获得serviceB的早期对象，serviceB还未填充属性，未进行任何初始化操作。
            5.  对serviceB对象进行属性填充操作和初始化操作等后续操作时，发现serviceB对象依赖serviceA对象。
            6.  serviceA是单例对象，因此，spring从Ioc容器中查询目标bean serviceA，先从三级缓存（第一级缓存、第二级缓存、第三级缓存）中依次查询。
            7.  如果缓存中查询到了则直接返回serviceA，查询不到则开始创建bean。
            8.  创建前首先去正在创建的bean列表中尝试加入当前bean，如果加入失败，说明当前bean正在被创建，即发生了循环依赖，直接报异常。
            9.  否则开始创建，spring实例化前将serviceA的beanName放入正在创建的bean缓存列表中缓存起来。
            10. spring调用空构造器实例化serviceA对象，此时获得serviceA的早期对象，serviceA还未填充属性，未进行任何初始化操作。
            11. 将早期的serviceA对象暴露给第三级缓存singletonFactories，进行缓存。
            12. 对serviceA对象进行属性填充操作和初始化操作等后续操作时，发现serviceA对象又依赖serviceB对象。
            13. 因此serviceB是多例，每次都需要创建一个新的serviceB，于是spring又开始重新创建serviceB。
            14. 创建前首先去正在创建的bean列表中尝试加入当前bean，如果加入失败，说明当前bean正在被创建，即发生了循环依赖，直接报异常。很明显到这一步，因为前面已经将serviceB加入到正在创建的bean列表中了，因此spring此处检测到了循环依赖，直接抛出异常了。
        </font>

        <font color="#a52a2a">情况3：serviceA单例，serviceB多例，应用直接获取serviceA（重点）</font>
        使用构造器构造器注入循环依赖，相互注入会直接报错。

        使用属性注入循环依赖，spring创建的简化步骤如下：
        <font color="gray">
            1.  serviceA是单例对象，因此，spring从Ioc容器中查询目标bean serviceA，先从三级缓存（第一级缓存、第二级缓存、第三级缓存）中依次查询。
            2.  如果缓存中查询到了则直接返回serviceA，查询不到则开始创建bean。
            3.  创建前首先去正在创建的bean列表中尝试加入当前bean，如果加入失败，说明当前bean正在被创建，即发生了循环依赖，直接报异常。
            4.  否则开始创建，spring实例化前将serviceA的beanName放入正在创建的bean缓存列表中缓存起来。
            5.  spring调用空构造器实例化serviceA对象，此时获得serviceA的早期对象，serviceA还未填充属性，未进行任何初始化操作。
            6.  将早期的serviceA对象暴露给第三级缓存singletonFactories，进行缓存。
            7.  对serviceA对象进行属性填充操作和初始化操作等后续操作时，发现serviceA对象依赖serviceB对象。
            8.  因为serviceB是多例，spring直接去创建serviceB。
            9.  创建前首先去正在创建的bean列表中尝试加入当前bean，如果加入失败，说明当前bean正在被创建，即发生了循环依赖，直接报异常。
            10. 否则开始创建，spring实例化前将serviceB的beanName放入正在创建的bean缓存列表中缓存起来。
            11. spring调用空构造器实例化serviceB对象，此时获得serviceB的早期对象，serviceB还未填充属性，未进行任何初始化操作。
            12. 对serviceB对象进行属性填充操作和初始化操作等后续操作时，发现serviceB对象依赖serviceA对象。
            13. 因为serviceA是单例，spring从Ioc容器中查询目标bean serviceA，先从三级缓存（第一级缓存、第二级缓存、第三级缓存）中依次查询。结果从第三级缓存中查询到了serviceA，于是将serviceA从第三级缓存singletonFactories中删除，移动到了第二级缓存earlySingletonObjects中。
            14. 将serviceA对象返回给serviceB对象，可以对serviceB对象进行属性填充操作和初始化操作等后续操作，此时的serviceA对象是早期对象，serviceB对象已经是完整对象了。
            15. 将serviceB对象从正在创建的bean缓存列表中移除。
            16. 返回创建好的serviceB对象给serviceA，可以对serviceA对象进行属性填充操作和初始化操作等后续操作，此时的serviceA对象已经是最终的完整对象。因为此时serviceA已经完整了，所以前面serviceB持有的serviceA的早期引用也已经变成了完整对象了。
            17. 将serviceA对象从正在创建的bean缓存列表中移除。
            18. 将serviceA对象放入第一级缓存singletonObjects中，并且从第二级缓存earlySingletonObjects和第三级缓存singletonFactories中删除。
        </font>

        <font color="#a52a2a">
            总结：
            对于产生循环依赖的两个对象，如果其中一个是单例，一个是多例，那么是否存在循环依赖问题，要看首先容器获取的单例对象还是多例对象。
            如果先获取单例对象，则不发生循环依赖问题。
            如果先获取多例对象，则发生循环依赖问题。
        </font>
    </pre>
</div>
</body>
</html>
