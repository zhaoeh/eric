package demo01.myspring.run.demo.hello;

/**
 * 一个不使用ioc控制反转的例子。
 * <p>
 * 不使用spring的ioc进行依赖注入的话，则当前类中的成员变量需要自己去实例化。
 * <p>
 * 1、spring的IOC容器：
 * IOC容器的顶层接口 BeanFactory，其中spring在BeanFactory的基础上扩展了更为强大的很多子接口，常见的如下：
 * XmlBeanFactory：专门用来实例化xml方式配置的bean的。XmlBeanFactory类是BeanFactory的实现类。
 * ApplicationContext：通用的加载spring容器，ApplicationContext接口是BeanFactory的子接口。
 * AnnotationConfigApplicationContext:基于注解的IOC容器，常常用于java配置方式的注解容器。
 * <p>
 * 2、向IOC容器中注册bean定义、实例化bean对象、将其他IOC中反射出的bean对象注入到当前bean的某个成员上。
 * 一个目标bean交给IOC容器管理，主要包括三个方面；
 * （1）、将目标bean的类定义注册到IOC容器中，即注册目标bean的权限定名；
 * （2）、根据注册的权限定名反射出目标bean的实例化对象；
 * （3）、将IOC中其他实例化好的bean对象注入到当前创建的bean的某个属性成员上，即依赖注入。
 * 详解原生xml配置的<bean>标签配置：
 * 原生xml配置中，<bean>标签的作用有三个：
 * 一是注册目标类定义到IOC容器中；二是通过反射目标类定义去实例化目标类对象（大多数情况下会缓存到IOC容器的map中）；三是将其他IOC管理的bean注入到当前bean的某个成员变量上即依赖注入。
 * jdk5引入注解后，实际上注解将<bean>标签的上述功能进行了明确的划分：
 * （1）、读取目标bean定义并注册到IOC容器的过程：替代注解有@ComponentScan、@Import、@Bean等，即通过扫描注解告知IOC容器当前bean的类定义，即权限定名；
 * （2）、通过反射实例化目标bean对象的过程：替代注解有@Repository、@Component、@Controller、@Service等。
 * （3）、将其他IOC容器中管理的bean注入到当前bean的某个属性中：替代注解有@Autowired和@Resource。
 * <p>
 * 3、详解IOC容器的三大作用：
 * 原理：根据IOC容器中注册的bean定义进行目标bean对象的实例化，并进行相关bean的依赖注入，随后通过IOC容器的统一接口可以从IOC容器的缓存中获取到实例bean。
 * <p>
 * 方式1：注册目标bean定义的同时并实例化目标bean对象，同时将IOC管理的其他bean对象注入到当前bean的某个成员上：
 * <p>
 * （1）、xml配置中使用<bean>标签，将目标bean的定义注册到IOC容器中并进行实例化，且注入其他bean的依赖；缺点：需要配置很多bean标签，很繁琐。
 * <p>
 * 方式2：只注册目标bean定义到IOC容器中的方式（实例化方式需要自己实现）：
 * （1）、@Bean：标注在一个方法上，根据方法返回值注册目标bean定义到IOC容器中，并根据该方法的内部逻辑实例化目标bean。@Bean注解的name属性
 * 用于手动指定bean对象的名称，如果不指定，则默认将当前方法名称作为bean对象名称交给spring的IOC容器进行管理。相当于xml中的<bean>，只不过实例化需要显式实现。
 * 该注解常常用于手动注册 外部第三方的bean。缺点：每个bean的注册都需要实现一个方法去实例化bean对象，几乎和<bean>标签一样繁琐。
 * 引申：如果一个个bean实例通过<bean>标签或者@Bean注册到IOC容器中，将很麻烦。所以出现了很多注解的方式（即只注册bean定义到IOC容器的方式，和@Bean一样只不过是批量的）：
 * （2）、注解@ComponentScan：默认扫描@SpringBootApplication所在类或者该注解标注的类的同级目录以及它的子目录。可以通过basePackages属性显式指定扫描的包路径。
 * 注解@ComponentScan可配置属性很多，详情请查看源码。
 * （3）、注解@Import导入不被 @ComponentScan注册到的外部组件。
 * <p>
 * 方式3：只实例化目标bean对象的方式：（因为下面注解的前提是首先要注册目标bean定义到IOC容器中才会由IOC容器实例化目标bean对象，所以常常结合@ComponentScan、@Import注解使用）
 * （1）、@Component：标注在目标类上，通过注解扫描器自动扫描到该类（扫描器实际上就是注册目标bean定义到IOC容器中），然后实例化该类对象。
 * bean对象名称默认为类名的首字母小写。可以显式指定value属性的值，用于指定bean对象名称。
 * （2）、@Controller、@Service、@Repository等都是对 @Component注解的变种，根据业务层级自动创建bean实例并注册到IOC容器中。
 * <p>
 * 方式4：依赖注入
 * 注解@Autowired：自动按照类型注入Spring容器中的bean对象。
 * 如果bean不是唯一的，再按照bean的名称和注入时作为属性成员的名称是否一致来进行依赖配置，如果匹配不上则抛出异常。
 * 注解@Autowired即自动配置bean的依赖关系。
 * 底层是通过IOC容器的getBean()方法获取到IOC容器中的bean对象，然后 通过反射直接将该对象注入到目标类的属性中，避免了大量的setter方法和getter方法的编写（注意，反射可以直接操作一个类的private属性）。
 * 注解@Autowired还可以设置required属性，默认为true。当要配置的依赖bean不一定存在时，可以设置required=false。
 * <p>
 * 4、注解@Qualifier
 * 当目标bean存在多个时，此时@Autowired配合 @Qualifier，可以消除歧义。@Qualifier中指定具体的bean的名称。
 *
 * @类名称： HelloDAO
 * @作者： zhaoerhu
 * @创建时间： 2019-3-7
 * @修改时间： 2019-3-7下午6:36:16
 * @备注：尊重每一行代码！
 */
// DAO层，直接与数据打交道
class HelloDAO {
    public void sayHello() {
        System.out.println("原生模拟spring，不使用IOC....");
    }
}

// 逻辑层，负责与DAO层交互
class HelloService {
    //service层委托的dao对象需要自己手动实例化，不借助IOC容器。
    private HelloDAO helloDao = new HelloDAO();

    public void service() {
        helloDao.sayHello();// 调用DAO层
    }
}

// 应用层，web应用中是页面显示，应用层是程序执行的入口，负责将请求提交到控制层
public class Demo01HelloIOCMain {
    public static void main(String args[]) {
        //同样，Service对象也没有交给IOC注册并实例化，而是自己手动实例化。
        HelloService service = new HelloService();
        service.service();// 调用service层
    }
}
