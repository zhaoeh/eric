

    <b><a name='header-n4' class='md-header-anchor '></a>4、isPrimitive方法</b><br>
    <pre class='md-fences mock-cm' style='display:block;position:relative'>
        之所以将isPrimitive方法单独拎出来说，是因为 isPrimitive 方法牵扯到Class类、Field类、包装类、JVM内置的9个class对象等基本类型的复杂关系，需要一步步深入搞懂。
    </pre>
    <b><a name='header-n41' class='md-header-anchor '></a>4.1、 isPrimitive方法能干啥</b>
    <pre class='md-fences mock-cm' style='display:block;position:relative'>
        1.  public boolean isPrimitive();
        2.  说明：判定指定的 Class 对象是否表示一个基本类型。有九种预定义的 Class 对象，表示八个基本类型和 void。这些类对象由 Java 虚拟机创建，与其表示的基本类型同名，即 boolean、byte、char、short、int、long、float 和 double。
        3.  返回值：如果是上述9种class对象的话，则返回true，否则返回false。
        4.  备注：上面的9种class对象，只能通过public static final类型的字段进行访问，不能通过getClass()方法或者Class.forName()进行访问。比如：
            int.class,void.class,boolean.class等。
            并且，整个java中也就只有这9种class对象能够使isPrimitive()方法返回true。
        5.  isPrimitive()总结下，就是来判断传入的一个class对象是否是基本类型和void类型的。
        6.  测试：
        package zeh.test.demo.com;

        /**
         * 功能描述
         *
         * @author zWX5331241
         * @since 2020-06-24
         */
        public class Test {

            public static void main(String args[]) {
                System.out.println(void.class.isPrimitive());
                System.out.println(int.class.isPrimitive());
                System.out.println(float.class.isPrimitive());
                System.out.println(boolean.class.isPrimitive());
                System.out.println(Integer.class.isPrimitive());
            }
        }

        7.  测试结果：
        true
        true
        true
        true
        false

        Process finished with exit code 0

        8.  疑问？
        上面案例中，凡是JVM预创建的9种class对象，isPrimitive都返回了true。
        然而，对于基本类型的包装类，比如Integer，它的class对象通过 isPrimitive 竟然返回了false。
        而往往，实际业务中，我们认为8大基本类型的包装类，也应该是我们认知当中的基本类型，那显然，此处单纯通过 isPrimitive 方法去验证，对于包装类就失效了。
        对于包装类，我们该如何进行验证？
    </pre>
    <b><a name='header-n42' class='md-header-anchor '></a>4.2、 class对象直接输出</b>
    <pre class='md-fences mock-cm' style='display:block;position:relative'>
        1.  任何一个class对象直接输出，则表示该class对象表示的权限定名称，即它表示的类链接符。因为Class的toString()方法实现了覆盖。
        2.  Class类覆盖后的toString方法如下：
            public String toString() {
                return (isInterface() ? "interface " : (isPrimitive() ? "" : "class ")) + getName();
            }
        3.  测试：
            package zeh.test.demo.com;

            /**
             * 功能描述
             *
             * @author zWX5331241
             * @since 2020-06-24
             */
            public class Test {

                public static void main(String args[]) {
                    System.out.println("Person.class is : " + Person.class);
                    System.out.println("Integer.class is : " + Integer.class);
                    System.out.println("int.class is : " + int.class);
                    System.out.println("void.class is : " + void.class);
                    System.out.println("boolean.class is : " + boolean.class);
                    System.out.println("char.class is : " + char.class);
                }
            }

        4.  测试结果：
        Person.class is : class zeh.test.demo.com.Person
        Integer.class is : class java.lang.Integer
        int.class is : int
        void.class is : void
        boolean.class is : boolean
        char.class is : char

        Process finished with exit code 0

        5.  结果分析：
        通过测试可以发现，如果是JVM预创建的9种内置class对象的话，其class对象直接输出的话，直接输出的就是其表示的基本类型或者void的名称。即，int.class直接输出就是int，void.class直接输出就是void。
        如果不是预创建的9种内置class对象，而是普通的引用类型的class对象，则class对象直接输出的格式为：class class对象描述的类的权限定名称。
    </pre>
    <b><a name='header-n43' class='md-header-anchor '></a>4.3、 Field对象直接输出</b>
    <pre class='md-fences mock-cm' style='display:block;position:relative'>
        1.  Field类用来描述一个类里面的成员变量。
        2.  Field类的toString()方法实现了覆盖，直接输出一个field对象，就是输出该field对象描述的字段的权限定信息。
        3.  Field类的toString()方法覆盖如下：
            public String toString() {
                int mod = getModifiers();
                return (((mod == 0) ? "" : (Modifier.toString(mod) + " "))
                    + getType().getTypeName() + " "
                    + getDeclaringClass().getTypeName() + "."
                    + getName());
            }
        4.  Class类中有个getField()方法，一般通过class对象调用该方法，指定字段名称，就会返回该class对象描述的目标类中指定成员的Field实例。如果指定的字段名称在对应的目标类中不存在，则抛出异常。
        5.  测试：
        package zeh.test.demo.com;

        /**
         * 功能描述
         *
         * @author zWX5331241
         * @since 2020-06-24
         */
        public class Test {

            public static void main(String args[]) throws NoSuchFieldException {
                System.out.println(Person.class.getField("name"));
                System.out.println(Integer.class.getField("TYPE"));
                System.out.println(Person.class.getField("CAO"));
            }
        }

        6.  测试结果：
        public java.lang.String zeh.test.demo.com.Person.name
        public static final java.lang.Class java.lang.Integer.TYPE
        Exception in thread "main" java.lang.NoSuchFieldException: CAO
            at java.lang.Class.getField(Class.java:1703)
            at zeh.test.demo.com.Test.main(Test.java:14)

        Process finished with exit code 1
    </pre>
    <b><a name='header-n44' class='md-header-anchor '></a>4.4、 Field对象获取指定对象上的当前字段值</b>
    <pre class='md-fences mock-cm' style='display:block;position:relative'>
        1.  Field类用来描述一个类里面的属性成员信息的。
        2.  Field提供了一个方法：public Object get(Object obj) throws IllegalArgumentException,IllegalAccessException;
        3.  返回值：对象obj中所表示的字段的值。
        4.  注意点：
            如果底层字段是一个静态字段，则忽略 obj 变量，直接传入一个null值即可。
            其他注意点参考Java API。
        5.  测试：
        package zeh.test.demo.com;

        /**
         * 功能描述
         *
         * @author zWX5331241
         * @since 2020-06-24
         */
        public class Test {

            public static void main(String args[]) throws NoSuchFieldException, IllegalAccessException {
                System.out.println(Person.class.getField("name").get(new Person("Eric")));
                System.out.println("Integer.class TYPE is : " + Integer.class.getField("TYPE"));
                System.out.println(Integer.class.getField("TYPE").get(null));
            }
        }

        6.  测试结果：
        Eric
        Integer.class TYPE is : public static final java.lang.Class java.lang.Integer.TYPE
        int

        Process finished with exit code 0

        7.  结果分析：
        System.out.println(Person.class.getField("name").get(new Person("Eric")));输出了Eric，很好理解。因为Person.class描述的目标类是Person，所以getField("name")获取的Field对象就是描述Person类里面的name字段的。然后去获取指定实例对象new Person("Eric")中的name字段的值，即Eric。

        重点分析：System.out.println(Integer.class.getField("TYPE").get(null));
        Integer类是int的包装类，不是我们自定义的类。而且我们看到 Integer.class.getField("TYPE") 输出的是 public static final java.lang.Class java.lang.Integer.TYPE。
        说明了Integer内部有一个常量字段TYPE。
        我们查看Integer的源码：
        public static final Class&lt;Integer&gt;  TYPE = (Class&lt;Integer&gt;) Class.getPrimitiveClass("int");

        Class.getPrimitiveClass("int")方法是Class类的内部方法，用来获取基本类型的class对象，所以说：Integer内部的TYPE字段实际上就是JAVA虚拟机内置的int的class对象。
        即：Integer.TYPE == int.class。其他包装类类似。

        同时，因为TYPE字段是static的，所以 Integer.class.getField("TYPE").get(null) 直接传入了一个null值。
        很显然从TYPE字段的定义中就看到，Integer类一旦被JVM装载，TYPE字段就初始化为int的内置class对象了。
        现在得出结论了：Integer.class.getField("TYPE").get(null);最终返回的是Integer内部的TYPE字段的值，这个值实际上就是int基本类型的class对象。
    </pre>
    <b><a name='header-n45' class='md-header-anchor '></a>4.5、 isPrimitive识别包装类</b>
    <pre class='md-fences mock-cm' style='display:block;position:relative'>
        1.  回到刚开始的问题，isPrimitive 方法不能直接判断包装类，直接判断包装类将返回false。即意味着该方法认为包装类不是一个预创建的基本类型（很明显包装类的class对象确实不是9种预创建的class对象之一）。
        2.  但我们在业务中，认为基本类型和包装类实际上是代表相同的业务含义的，即我们认为：int和Integer的业务含义是完全相同的。
        3.  那么，如何通过 isPrimitive 方法处理包装类的类型认证呢？
        4.  猜想：
            既然 isPrimitive 方法只能判断JVM预创建的9种基本类型的class对象，那么要想使用 isPrimitive 去正确判断对应的包装类型，应该想办法从对应的包装类型中获取到与之相关联的预创建的class对象。
        5.  通过上面的测试已经有了方案：
            Integer.class.getField("TYPE").get(null);返回的是Integer内部的TYPE字段的值，实际上就是JVM预创建的int的class对象。
        7.  挨个查看8种包装类的TYPE字段的定义：
            Byte类中的TYPE字段：public static final Class<&lt;Byte&gt; TYPE = (Class&lt;Byte&gt;) Class.getPrimitiveClass("byte");
            Short类中的TYPE字段：public static final Class<&lt;Short&gt; TYPE = (Class&lt;Short&gt;) Class.getPrimitiveClass("short");
            Integer类中的TYPE字段：public static final Class<&lt;Integer&gt; TYPE = (Class&lt;Integer&gt;) Class.getPrimitiveClass("int");
            Long类中的TYPE字段：public static final Class<&lt;Long&gt; TYPE = (Class&lt;Long&gt;) Class.getPrimitiveClass("long");
            Float类中的TYPE字段：public static final Class<&lt;Float&gt; TYPE = (Class&lt;Float&gt;) Class.getPrimitiveClass("float");
            Double类中的TYPE字段：public static final Class<&lt;Double&gt; TYPE = (Class&lt;Double&gt;) Class.getPrimitiveClass("double");
            Boolean类中的TYPE字段：public static final Class<&lt;Boolean&gt; TYPE = (Class&lt;Boolean&gt;) Class.getPrimitiveClass("boolean");
            Character类中的TYPE字段：public static final Class<&lt;Character&gt; TYPE = (Class&lt;Character&gt;) Class.getPrimitiveClass("char");

        8.  我们全面验证下8种包装类型的TYPE字段取出来都是啥：
        package zeh.test.demo.com;

        /**
         * 功能描述
         *
         * @author zWX5331241
         * @since 2020-06-24
         */
        public class Test {

            public static void main(String args[]) throws NoSuchFieldException, IllegalAccessException {
                System.out.println(Byte.class.getField("TYPE").get(null));
                System.out.println(Short.class.getField("TYPE").get(null));
                System.out.println(Integer.class.getField("TYPE").get(null));
                System.out.println(Long.class.getField("TYPE").get(null));
                System.out.println(Float.class.getField("TYPE").get(null));
                System.out.println(Double.class.getField("TYPE").get(null));
                System.out.println(Boolean.class.getField("TYPE").get(null));
                System.out.println(Character.class.getField("TYPE").get(null));
            }
        }

        9.  我们看到8种包装类型中，TYPE字段实际上都是public static final的，即本身就是常量，因此，我们可以直接通过包装类的类名进行访问：
        package zeh.test.demo.com;

        /**
         * 功能描述
         *
         * @author zWX5331241
         * @since 2020-06-24
         */
        public class Test {

            public static void main(String args[]) {
                System.out.println(Byte.TYPE);
                System.out.println(Short.TYPE);
                System.out.println(Integer.TYPE);
                System.out.println(Long.TYPE);
                System.out.println(Float.TYPE);
                System.out.println(Double.TYPE);
                System.out.println(Boolean.TYPE);
                System.out.println(Character.TYPE);
            }
        }

        10. 上面两种方式的测试结果是一致的，如下：
        byte
        short
        int
        long
        float
        double
        boolean
        char

        Process finished with exit code 0

    </pre>
    <b><a name='header-n46' class='md-header-anchor '></a>4.6、 isPrimitive实现基本类型和对应包装类型的通用判断</b>
    <pre class='md-fences mock-cm' style='display:block;position:relative'>
        1.  基于上面的分析，我们知道，isPrimitive 去判断基本类型是很直观的，因为JVM为基本类型预创建的class对象，通过isPrimitive返回的就是true。
        2.  isPrimitive 去判断包装类型，可以先获取到包装类型里面的TYPE字段的值，因为TYPE字段的值表示的就是包装类型对应的预创建的基本类型的class对象，比如Integer类里面的TYPE字段的值表示的就是JVM预创建的int类型的class对象。
        3.  获取包装类的TYPE字段的值有两种方式，以Integer举例：
            （1） Integer.class.getField("TYPE").get(null);
            （2） Integer.TYPE;
        4.  分析上述两种方式，很明显，第二种直接通过包装类获取TYPE的方式根本无法进行扩展。因为如果要实现一个通用的方法去专门实现包装类型的判断的话，我们无法从外部就直接传入一个包装类的TYPE。因为我们不知道要传入的对象是啥啊。而第一种方式，外部只需要传入一个class对象即可。
        5.  测试：
        package zeh.test.demo.com;

        /**
         * 功能描述
         *
         * @author zWX5331241
         * @since 2020-06-24
         */
        public class Test {

            public static void main(String args[]) {
                System.out.println(isPrimitive(byte.class));
                System.out.println(isPrimitive(short.class));
                System.out.println(isPrimitive(int.class));
                System.out.println(isPrimitive(long.class));
                System.out.println(isPrimitive(float.class));
                System.out.println(isPrimitive(double.class));
                System.out.println(isPrimitive(boolean.class));
                System.out.println(isPrimitive(char.class));
                System.out.println(isPrimitive(Byte.class));
                System.out.println(isPrimitive(Short.class));
                System.out.println(isPrimitive(Integer.class));
                System.out.println(isPrimitive(Long.class));
                System.out.println(isPrimitive(Float.class));
                System.out.println(isPrimitive(Double.class));
                System.out.println(isPrimitive(Boolean.class));
                System.out.println(isPrimitive(Character.class));

                System.out.println(isPrimitive(Object.class));
                System.out.println(isPrimitive(Person.class));
            }

            /**
             * 判断目标clazz对象是否是基本类型或其对应的包装类型
             *
             * @param clazz 目标clazz对象
             * @return true：是基本类型 false：不是基本类型
             */
            public static boolean isPrimitive(Class clazz) {
                return clazz.isPrimitive() || isWrapPrimitive(clazz);
            }

            /**
             * 判断目标clazz对象是否是包装类型
             *
             * @param clazz 目标clazz对象
             * @return true：是包装类型 false：不是包装类型
             */
            public static boolean isWrapPrimitive(Class clazz) {
                try {
                    return ((Class) (clazz.getField("TYPE").get(null))).isPrimitive();
                } catch (Exception e) {
                    return false;
                }
            }
        }

        6.  测试结果：
        true
        true
        true
        true
        true
        true
        true
        true
        true
        true
        true
        true
        true
        true
        true
        true
        false
        false

        Process finished with exit code 0
    </pre>

    <b><a name='header-n5' class='md-header-anchor '></a>5、跟本地类、匿名类等相关的api测试</b><br>
    <b><a name='header-n51' class='md-header-anchor '></a>5.1、 修改上述案例中的ClassD如下：</b>
    <pre class='md-fences mock-cm' style='display:block;position:relative'>
        package zeh.test.demo.com.class1;

        /**
         * 功能描述 ClassD内部定义了各种内部类
         *
         * @author zWX5331241
         * @since 2021-03-11
         */
        public class ClassD extends ClassC {
            private static String staticStr = "外部类的静态成员";

            private String privateStr = "外部类的private成员";

            private String str = "外部类的成员";

            @Override
            public void abstractFun() {
                System.out.println("ClassD implements");
            }

            public void testD() {
                System.out.println("ClassD testD");
            }

            /**
             * 虽然内部类可以无条件的访问外部类的成员和方法，但是外部类想要访问内部类的成员和方法，就需要明确创建内部类的对象了。
             */
            public void doInnerField() {
                // 外部类中必须先常见成员内部类的对象才能访问内部类的成员和方法
                new Inter().testInner();
                System.out.println(new Inter().str);
            }

            /**
             * 定义一个成员内部类：成员内部类可以无条件的访问自己的外部类中测成员属性和成员方法（包括静态成员和private成员）
             */
            class Inter {

                private String str = "内部类的private成员，和外部类的private成员同名，将对外部类的private成员进行覆盖";

                /**
                 * 内部类定义了和外部类的同名方法，也将对外部类的同名方法进行覆盖。
                 */
                public void testD() {
                    System.out.println("Inter testD");
                }

                public void testInner() {
                    System.out.println("测试成员内部类，staticStr = " + staticStr + ";privateStr = " + privateStr);

                    // 因为成员内部类对外部类的同名属性和方法进行了覆盖，所以如果直接访问的话访问的将是内部类覆盖后的成员和方法。
                    System.out.println("访问str成员，实际上访问的就是内部类自己覆盖后的str：" + str);
                    // 直接执行testD方法也是一样
                    testD();

                    // 如果想继续访问外部类的成员和方法，则必须实例化一个ClassD外部类的对象;或者直接使用 "类名.this.成员" 的方式显式指定当前的this是内部类还是外部类的。
                    // 方式一：直接创建外部类对象。
                    new ClassD().testD();
                    System.out.println(new ClassD().str);

                    // 方式二：通过“外部类.this.成员”的方式指定this代表的是外部类的this。如果直接使用this肯定是当前类的this。
                    // 说明：“类名.this.成员”或者“类名.super.成员”这种方式只有在存在内部类外部类的时候才有这种语法。
                    ClassD.this.testD();
                    System.out.println(ClassD.this.str);
                }
            }


            /**
             * 定义一个方法，专门访问局部内部类
             */
            public void testFunInner() {

                /**
                 * 定义一个局部内部类，局部内部类是定义在方法或者某个作用域里面的，就像局部变量一样，是不能有任何访问权限修饰和static修饰的。
                 *
                 * 局部内部类也称为本地类。
                 *
                 * 局部内部类也可以无条件的访问外部类中的成员和方法。但是外部类可不能随意的访问局部内部类，只能在当前方法中才能访问局部内部类。
                 *
                 * 局部内部类和成员内部类的区别在于，局部内部类只能在当前的作用域或者当前的方法中进行访问。
                 */
                class FunInner {
                    private String funStr = "局部内部类的成员";

                    private String str = "局部内部类的private成员，和外部类的private成员同名，将对外部类的private成员进行覆盖";

                    public void testFunInner() {
                        System.out.println("局部内部类的方法，staticStr = " + staticStr + ";privateStr = " + privateStr);
                        System.out.println("访问str成员，实际上访问的就是局部内部类自己覆盖后的str：" + str);

                        // 明确指定要访问外部类的同名成员才可
                        System.out.println(ClassD.this.str);
                    }
                }

                // 只能在当前域中访问局部内部类，同理，需要创建局部内部类的对象才能访问局部内部类
                FunInner funInner = new FunInner();
                funInner.testFunInner();
                System.out.println(new FunInner().funStr);

                // 判断 FunInner 是否是本地类
                System.out.println("FunInner 是否是本地类？" + FunInner.class.isLocalClass());
            }


            /**
             * 定义一个方法，专门实现匿名内部类。
             * 匿名内部类一般用于实现接口，通过匿名实现接口进行回调逻辑的指定。
             */
            public MyInterface testNiMingInner() {
                // 没有定义类名，直接创建某个类的对象，并实现某个类中的方法。
                // 匿名内部类的实现必须具备父类或者接口的前提，才有匿名内部类的实现。
                // 匿名内部类是唯一一种没有构造器的类。正因为其没有构造器，所以匿名内部类的使用范围非常有限，大部分匿名内部类用于接口回调。
                // 匿名内部类在编译的时候由系统自动起名为Outter$1.class。一般来说，匿名内部类用于继承其他类或是实现接口，并不需要增加额外的方法，只是对继承方法的实现或是重写。
                MyInterface myInterface = new MyInterface() {
                    @Override
                    public void abstractFun() {
                        System.out.println("匿名内部类实现的abstractFun");
                    }

                    @Override
                    public void eat() {
                        System.out.println("匿名内部类实现的eat");
                    }

                    @Override
                    public void drink() {
                        System.out.println("匿名内部类实现的drink");
                    }

                    @Override
                    public void sleep() {
                        System.out.println("匿名内部类实现的sleep");
                    }
                };
                myInterface.drink();
                myInterface.abstractFun();
                myInterface.eat();
                myInterface.sleep();

                // 返回该匿名类对象
                return myInterface;
            }

            /**
             * 定义一个静态内部类，静态内部类就好像一个类的静态成员。
             * 静态内部类不能访问外部类的非静态成员，如果要访问，必须明确创建外部类的对象。
             */
            static class StaticInner {

                private String str = "静态内部类中的成员";

                public void testStaticInner() {
                    System.out.println("测试成员内部类，staticStr = " + staticStr + ";privateStr = " + new ClassD().privateStr);
                    System.out.println(str);
                }
            }
        }
    </pre>

</div>
</body>
</html>
